{
  "address": "0xb27c655b719C58E158132fa56d9b27ec51fFc459",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_lockupPeriod",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "_snapshotBlockNumber",
          "type": "uint256"
        },
        {
          "internalType": "bytes",
          "name": "_snapshotBlockHeader",
          "type": "bytes"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_spender",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "Approval",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "Claimed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_slasher",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "Slashed",
      "type": "event"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": true,
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "Transfer",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_spender",
          "type": "address"
        }
      ],
      "name": "allowance",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "allowed",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_spender",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "approve",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        }
      ],
      "name": "balanceOf",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "balances",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_owner",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "_proof",
          "type": "bytes"
        }
      ],
      "name": "claim",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "claimed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "decimals",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "lockupEndTime",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "name",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "_encodedEIP155Tx",
          "type": "bytes"
        }
      ],
      "name": "slash",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "name": "slashed",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "snapshotBlockHash",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "snapshotBlockNumber",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "snapshotStateRoot",
      "outputs": [
        {
          "internalType": "bytes32",
          "name": "",
          "type": "bytes32"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "symbol",
      "outputs": [
        {
          "internalType": "string",
          "name": "",
          "type": "string"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "totalSupply",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "transfer",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_from",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_to",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "_value",
          "type": "uint256"
        }
      ],
      "name": "transferFrom",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x3f8061784fc3d28f810322d79baf52eb1a1e1875fb7764472f9aa855e5a00373",
  "receipt": {
    "to": null,
    "from": "0x19E7E376E7C213B7E7e7e46cc70A5dD086DAff2A",
    "contractAddress": "0xb27c655b719C58E158132fa56d9b27ec51fFc459",
    "transactionIndex": 2,
    "gasUsed": "3608791",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xa6408a20631be4a7f1a9db118edb6d94ba6a118e66f757838fb9015b194a00bd",
    "transactionHash": "0x3f8061784fc3d28f810322d79baf52eb1a1e1875fb7764472f9aa855e5a00373",
    "logs": [],
    "blockNumber": 24000448,
    "cumulativeGasUsed": "3834388",
    "status": 1,
    "byzantium": true
  },
  "args": [
    0,
    24000447,
    {
      "0": 249,
      "1": 2,
      "2": 39,
      "3": 160,
      "4": 237,
      "5": 209,
      "6": 31,
      "7": 133,
      "8": 101,
      "9": 74,
      "10": 93,
      "11": 134,
      "12": 72,
      "13": 101,
      "14": 156,
      "15": 202,
      "16": 217,
      "17": 58,
      "18": 32,
      "19": 103,
      "20": 19,
      "21": 69,
      "22": 93,
      "23": 197,
      "24": 217,
      "25": 227,
      "26": 26,
      "27": 55,
      "28": 147,
      "29": 89,
      "30": 159,
      "31": 65,
      "32": 89,
      "33": 128,
      "34": 178,
      "35": 93,
      "36": 160,
      "37": 29,
      "38": 204,
      "39": 77,
      "40": 232,
      "41": 222,
      "42": 199,
      "43": 93,
      "44": 122,
      "45": 171,
      "46": 133,
      "47": 181,
      "48": 103,
      "49": 182,
      "50": 204,
      "51": 212,
      "52": 26,
      "53": 211,
      "54": 18,
      "55": 69,
      "56": 27,
      "57": 148,
      "58": 138,
      "59": 116,
      "60": 19,
      "61": 240,
      "62": 161,
      "63": 66,
      "64": 253,
      "65": 64,
      "66": 212,
      "67": 147,
      "68": 71,
      "69": 148,
      "70": 0,
      "71": 0,
      "72": 0,
      "73": 0,
      "74": 0,
      "75": 0,
      "76": 0,
      "77": 0,
      "78": 0,
      "79": 0,
      "80": 0,
      "81": 0,
      "82": 0,
      "83": 0,
      "84": 0,
      "85": 0,
      "86": 0,
      "87": 0,
      "88": 0,
      "89": 0,
      "90": 160,
      "91": 224,
      "92": 140,
      "93": 34,
      "94": 10,
      "95": 198,
      "96": 171,
      "97": 65,
      "98": 70,
      "99": 22,
      "100": 206,
      "101": 92,
      "102": 142,
      "103": 229,
      "104": 88,
      "105": 237,
      "106": 244,
      "107": 162,
      "108": 60,
      "109": 82,
      "110": 169,
      "111": 182,
      "112": 58,
      "113": 82,
      "114": 15,
      "115": 27,
      "116": 27,
      "117": 119,
      "118": 3,
      "119": 133,
      "120": 70,
      "121": 151,
      "122": 24,
      "123": 160,
      "124": 86,
      "125": 232,
      "126": 31,
      "127": 23,
      "128": 27,
      "129": 204,
      "130": 85,
      "131": 166,
      "132": 255,
      "133": 131,
      "134": 69,
      "135": 230,
      "136": 146,
      "137": 192,
      "138": 248,
      "139": 110,
      "140": 91,
      "141": 72,
      "142": 224,
      "143": 27,
      "144": 153,
      "145": 108,
      "146": 173,
      "147": 192,
      "148": 1,
      "149": 98,
      "150": 47,
      "151": 181,
      "152": 227,
      "153": 99,
      "154": 180,
      "155": 33,
      "156": 160,
      "157": 86,
      "158": 232,
      "159": 31,
      "160": 23,
      "161": 27,
      "162": 204,
      "163": 85,
      "164": 166,
      "165": 255,
      "166": 131,
      "167": 69,
      "168": 230,
      "169": 146,
      "170": 192,
      "171": 248,
      "172": 110,
      "173": 91,
      "174": 72,
      "175": 224,
      "176": 27,
      "177": 153,
      "178": 108,
      "179": 173,
      "180": 192,
      "181": 1,
      "182": 98,
      "183": 47,
      "184": 181,
      "185": 227,
      "186": 99,
      "187": 180,
      "188": 33,
      "189": 185,
      "190": 1,
      "191": 0,
      "192": 0,
      "193": 0,
      "194": 0,
      "195": 0,
      "196": 0,
      "197": 0,
      "198": 0,
      "199": 0,
      "200": 0,
      "201": 0,
      "202": 0,
      "203": 0,
      "204": 0,
      "205": 0,
      "206": 0,
      "207": 0,
      "208": 0,
      "209": 0,
      "210": 0,
      "211": 0,
      "212": 0,
      "213": 0,
      "214": 0,
      "215": 0,
      "216": 0,
      "217": 0,
      "218": 0,
      "219": 0,
      "220": 0,
      "221": 0,
      "222": 0,
      "223": 0,
      "224": 0,
      "225": 0,
      "226": 0,
      "227": 0,
      "228": 0,
      "229": 0,
      "230": 0,
      "231": 0,
      "232": 0,
      "233": 0,
      "234": 0,
      "235": 0,
      "236": 0,
      "237": 0,
      "238": 0,
      "239": 0,
      "240": 0,
      "241": 0,
      "242": 0,
      "243": 0,
      "244": 0,
      "245": 0,
      "246": 0,
      "247": 0,
      "248": 0,
      "249": 0,
      "250": 0,
      "251": 0,
      "252": 0,
      "253": 0,
      "254": 0,
      "255": 0,
      "256": 0,
      "257": 0,
      "258": 0,
      "259": 0,
      "260": 0,
      "261": 0,
      "262": 0,
      "263": 0,
      "264": 0,
      "265": 0,
      "266": 0,
      "267": 0,
      "268": 0,
      "269": 0,
      "270": 0,
      "271": 0,
      "272": 0,
      "273": 0,
      "274": 0,
      "275": 0,
      "276": 0,
      "277": 0,
      "278": 0,
      "279": 0,
      "280": 0,
      "281": 0,
      "282": 0,
      "283": 0,
      "284": 0,
      "285": 0,
      "286": 0,
      "287": 0,
      "288": 0,
      "289": 0,
      "290": 0,
      "291": 0,
      "292": 0,
      "293": 0,
      "294": 0,
      "295": 0,
      "296": 0,
      "297": 0,
      "298": 0,
      "299": 0,
      "300": 0,
      "301": 0,
      "302": 0,
      "303": 0,
      "304": 0,
      "305": 0,
      "306": 0,
      "307": 0,
      "308": 0,
      "309": 0,
      "310": 0,
      "311": 0,
      "312": 0,
      "313": 0,
      "314": 0,
      "315": 0,
      "316": 0,
      "317": 0,
      "318": 0,
      "319": 0,
      "320": 0,
      "321": 0,
      "322": 0,
      "323": 0,
      "324": 0,
      "325": 0,
      "326": 0,
      "327": 0,
      "328": 0,
      "329": 0,
      "330": 0,
      "331": 0,
      "332": 0,
      "333": 0,
      "334": 0,
      "335": 0,
      "336": 0,
      "337": 0,
      "338": 0,
      "339": 0,
      "340": 0,
      "341": 0,
      "342": 0,
      "343": 0,
      "344": 0,
      "345": 0,
      "346": 0,
      "347": 0,
      "348": 0,
      "349": 0,
      "350": 0,
      "351": 0,
      "352": 0,
      "353": 0,
      "354": 0,
      "355": 0,
      "356": 0,
      "357": 0,
      "358": 0,
      "359": 0,
      "360": 0,
      "361": 0,
      "362": 0,
      "363": 0,
      "364": 0,
      "365": 0,
      "366": 0,
      "367": 0,
      "368": 0,
      "369": 0,
      "370": 0,
      "371": 0,
      "372": 0,
      "373": 0,
      "374": 0,
      "375": 0,
      "376": 0,
      "377": 0,
      "378": 0,
      "379": 0,
      "380": 0,
      "381": 0,
      "382": 0,
      "383": 0,
      "384": 0,
      "385": 0,
      "386": 0,
      "387": 0,
      "388": 0,
      "389": 0,
      "390": 0,
      "391": 0,
      "392": 0,
      "393": 0,
      "394": 0,
      "395": 0,
      "396": 0,
      "397": 0,
      "398": 0,
      "399": 0,
      "400": 0,
      "401": 0,
      "402": 0,
      "403": 0,
      "404": 0,
      "405": 0,
      "406": 0,
      "407": 0,
      "408": 0,
      "409": 0,
      "410": 0,
      "411": 0,
      "412": 0,
      "413": 0,
      "414": 0,
      "415": 0,
      "416": 0,
      "417": 0,
      "418": 0,
      "419": 0,
      "420": 0,
      "421": 0,
      "422": 0,
      "423": 0,
      "424": 0,
      "425": 0,
      "426": 0,
      "427": 0,
      "428": 0,
      "429": 0,
      "430": 0,
      "431": 0,
      "432": 0,
      "433": 0,
      "434": 0,
      "435": 0,
      "436": 0,
      "437": 0,
      "438": 0,
      "439": 0,
      "440": 0,
      "441": 0,
      "442": 0,
      "443": 0,
      "444": 0,
      "445": 0,
      "446": 0,
      "447": 0,
      "448": 144,
      "449": 255,
      "450": 255,
      "451": 255,
      "452": 255,
      "453": 255,
      "454": 255,
      "455": 255,
      "456": 255,
      "457": 255,
      "458": 255,
      "459": 255,
      "460": 255,
      "461": 255,
      "462": 255,
      "463": 255,
      "464": 253,
      "465": 132,
      "466": 1,
      "467": 110,
      "468": 55,
      "469": 191,
      "470": 131,
      "471": 190,
      "472": 188,
      "473": 32,
      "474": 131,
      "475": 24,
      "476": 228,
      "477": 105,
      "478": 132,
      "479": 96,
      "480": 86,
      "481": 108,
      "482": 36,
      "483": 156,
      "484": 219,
      "485": 131,
      "486": 3,
      "487": 0,
      "488": 0,
      "489": 140,
      "490": 79,
      "491": 112,
      "492": 101,
      "493": 110,
      "494": 69,
      "495": 116,
      "496": 104,
      "497": 101,
      "498": 114,
      "499": 101,
      "500": 117,
      "501": 109,
      "502": 134,
      "503": 49,
      "504": 46,
      "505": 52,
      "506": 52,
      "507": 46,
      "508": 48,
      "509": 130,
      "510": 108,
      "511": 105,
      "512": 160,
      "513": 0,
      "514": 0,
      "515": 0,
      "516": 0,
      "517": 0,
      "518": 0,
      "519": 0,
      "520": 0,
      "521": 0,
      "522": 0,
      "523": 0,
      "524": 0,
      "525": 0,
      "526": 0,
      "527": 0,
      "528": 0,
      "529": 0,
      "530": 0,
      "531": 0,
      "532": 0,
      "533": 0,
      "534": 0,
      "535": 0,
      "536": 0,
      "537": 0,
      "538": 0,
      "539": 0,
      "540": 0,
      "541": 0,
      "542": 0,
      "543": 0,
      "544": 0,
      "545": 136,
      "546": 0,
      "547": 0,
      "548": 0,
      "549": 0,
      "550": 0,
      "551": 0,
      "552": 0,
      "553": 0
    }
  ],
  "solcInputHash": "10529fe9554a7b7e327c07310d09186e",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_lockupPeriod\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"_snapshotBlockNumber\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"_snapshotBlockHeader\",\"type\":\"bytes\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_slasher\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Slashed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_spender\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"_proof\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"lockupEndTime\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"_encodedEIP155Tx\",\"type\":\"bytes\"}],\"name\":\"slash\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"name\":\"slashed\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotBlockHash\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotBlockNumber\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"snapshotStateRoot\",\"outputs\":[{\"internalType\":\"bytes32\",\"name\":\"\",\"type\":\"bytes32\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"internalType\":\"string\",\"name\":\"\",\"type\":\"string\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_from\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"claim(address,bytes)\":{\"params\":{\"_owner\":\"Address to claim tokens for.\",\"_proof\":\"RLP-encoded merkle trie inclusion proof for the address's account at the               snapshot block height.\"},\"returns\":{\"_0\":\"`true` if the function succeeded.\"}},\"slash(bytes)\":{\"params\":{\"_encodedEIP155Tx\":\"RLP-encoded signed EIP155 transaction.\"},\"returns\":{\"_0\":\"`true` if the slashin' was successful.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"claim(address,bytes)\":{\"notice\":\"Function for redeeming tokens at a 1:1 ratio to ETH at the snapshot block. If you had 1 ETH (= 10^18 wei) at the snapshot, you have 10^18 tokens. I.e., you have the same amount of tokens. Also allows you to claim on behalf of someone else (*you* do the proof, *they* get the money). Perhaps useful if you want to quickly claim and slash.\"},\"slash(bytes)\":{\"notice\":\"Slashes an account based on a signed EIP155 transaction with a chain ID other than 1. Simply provide the encoded signed transaction and be rewarded with the heretic's entire (claimed) balance! Will *not* work if the user you're slashing hasn't claimed a balance yet. But you can also claim on behalf of other users if you want to do some slashin'.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/ETHMaxiToken.sol\":\"ETHMaxiToken\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":false,\"runs\":200},\"remappings\":[]},\"sources\":{\"contracts/ETHMaxiToken.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"./libraries/Lib_RLPReader.sol\\\";\\nimport { Lib_SecureMerkleTrie } from \\\"./libraries/Lib_SecureMerkleTrie.sol\\\";\\nimport { Lib_EIP155Tx } from \\\"./libraries/Lib_EIP155Tx.sol\\\";\\n\\ncontract ETHMaxiToken {\\n    using Lib_EIP155Tx for Lib_EIP155Tx.EIP155Tx;\\n\\n    event Transfer(\\n        address indexed _from,\\n        address indexed _to,\\n        uint256 _value\\n    );\\n\\n    event Approval(\\n        address indexed _owner,\\n        address indexed _spender,\\n        uint256 _value\\n    );\\n\\n    event Claimed(\\n        address indexed _owner,\\n        uint256 _value\\n    );\\n\\n    event Slashed(\\n        address indexed _owner,\\n        address indexed _slasher,\\n        uint256 _value\\n    );\\n\\n    // Just convenient for interfaces.\\n    string public constant name = 'Maxi ETH';\\n    string public constant symbol = 'mETH';\\n    uint256 public constant decimals = 18;\\n\\n    // Will be dynamic, depends on total ETH supply at time of snapshot. Will increase as more\\n    // people claim.\\n    uint256 public totalSupply;\\n\\n    // Balance/allowance mappings.\\n    mapping (address => uint256) public balances;\\n    mapping (address => mapping (address => uint256)) public allowed;\\n    \\n    // Make sure people can't claim more than once.\\n    mapping (address => bool) public claimed;\\n\\n    // Make sure people can't get slashed more than once.\\n    mapping (address => bool) public slashed;\\n\\n    // When the lockup ends.\\n    uint256 public lockupEndTime;\\n\\n    // Hashes that people will use to prove their balances.\\n    uint256 public snapshotBlockNumber;\\n    bytes32 public snapshotBlockHash;\\n    bytes32 public snapshotStateRoot;\\n\\n    constructor(\\n        uint256 _lockupPeriod,\\n        uint256 _snapshotBlockNumber,\\n        bytes memory _snapshotBlockHeader\\n    ) {\\n        lockupEndTime = block.timestamp + _lockupPeriod;\\n        snapshotBlockNumber = _snapshotBlockNumber;\\n        snapshotBlockHash = blockhash(_snapshotBlockNumber);\\n\\n        // // Just a safety measure.\\n        // require(\\n        //     keccak256(_snapshotBlockHeader) == snapshotBlockHash,\\n        //     \\\"ETHMaxiToken: block header does not match snapshot block hash\\\"\\n        // );\\n\\n        // Decode the block header in order to pull out the state root.\\n        Lib_RLPReader.RLPItem[] memory blockHeader = Lib_RLPReader.readList(\\n            _snapshotBlockHeader\\n        );\\n        snapshotStateRoot = Lib_RLPReader.readBytes32(blockHeader[3]);\\n    }\\n\\n    /**\\n     * We use a lockup period to prevent people from claiming and then transferring their tokens to\\n     * avoid getting slashed. Simple modifier for checking this condition.\\n     */\\n    modifier onlyAfterLockup() {\\n        require(\\n            block.timestamp > lockupEndTime,\\n            \\\"ETHMaxiToken: lockup hasn't ended yet, nerd\\\"\\n        );\\n        _;\\n    }\\n\\n    /**\\n     * Function for redeeming tokens at a 1:1 ratio to ETH at the snapshot block. If you had 1 ETH\\n     * (= 10^18 wei) at the snapshot, you have 10^18 tokens. I.e., you have the same amount of\\n     * tokens. Also allows you to claim on behalf of someone else (*you* do the proof, *they* get\\n     * the money). Perhaps useful if you want to quickly claim and slash.\\n     * @param _owner Address to claim tokens for.\\n     * @param _proof RLP-encoded merkle trie inclusion proof for the address's account at the\\n     *               snapshot block height.\\n     * @return `true` if the function succeeded.\\n     */\\n    function claim(\\n        address _owner,\\n        bytes memory _proof\\n    )\\n        public\\n        returns (\\n            bool\\n        )\\n    {\\n        // You can only claim once per address.\\n        require(\\n            claimed[_owner] == false,\\n            \\\"ETHMaxiToken: balance for address has already been claimed\\\"\\n        );\\n\\n        // Pull out the encoded account from the merkle trie proof.\\n        (bool exists, bytes memory encodedAccount) = Lib_SecureMerkleTrie.get(\\n            abi.encodePacked(_owner),\\n            _proof,\\n            snapshotStateRoot\\n        );\\n\\n        require(\\n            exists == true,\\n            \\\"ETHMaxiToken: bad eth merkle proof\\\"\\n        );\\n\\n        // Decode account to get its balance.\\n        Lib_RLPReader.RLPItem[] memory account = Lib_RLPReader.readList(\\n            encodedAccount\\n        );\\n        uint256 amount = Lib_RLPReader.readUint256(account[1]);\\n\\n        // Mark as claimed and give out the balance.\\n        claimed[_owner] = true;\\n        balances[_owner] = amount;\\n\\n        emit Transfer(address(0), _owner, amount);\\n        emit Claimed(_owner, amount);\\n        return true;\\n    }\\n\\n    /**\\n     * Slashes an account based on a signed EIP155 transaction with a chain ID other than 1. Simply\\n     * provide the encoded signed transaction and be rewarded with the heretic's entire (claimed)\\n     * balance! Will *not* work if the user you're slashing hasn't claimed a balance yet. But you\\n     * can also claim on behalf of other users if you want to do some slashin'.\\n     * @param _encodedEIP155Tx RLP-encoded signed EIP155 transaction.\\n     * @return `true` if the slashin' was successful.\\n     */\\n    function slash(\\n        bytes memory _encodedEIP155Tx\\n    )\\n        public\\n        returns (\\n            bool\\n        )\\n    {\\n        Lib_EIP155Tx.EIP155Tx memory transaction = Lib_EIP155Tx.decode(\\n            _encodedEIP155Tx,\\n            1 // chain id of ethereum\\n        );\\n\\n        address owner = transaction.sender();\\n\\n        require(\\n            claimed[owner] == true,\\n            \\\"ETHMaxiToken: can't slash because the user hasn't claimed\\\"\\n        );\\n\\n        require(\\n            slashed[owner] == false,\\n            \\\"ETHMaxiToken: address has already been slashed\\\"\\n        );\\n\\n        uint256 amount = balances[owner];\\n\\n        slashed[owner] = true;\\n        balances[msg.sender] += amount;\\n        balances[owner] = 0;\\n        emit Transfer(owner, msg.sender, amount);\\n        emit Slashed(owner, msg.sender, amount);\\n        return true;\\n    }\\n\\n    function transfer(\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        onlyAfterLockup\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            balances[msg.sender] >= _value,\\n            \\\"ETHMaxiToken: you don't have enough balance to make this transfer\\\"\\n        );\\n\\n        balances[msg.sender] -= _value;\\n        balances[_to] += _value;\\n        emit Transfer(msg.sender, _to, _value);\\n        return true;\\n    }\\n\\n    function transferFrom(\\n        address _from,\\n        address _to,\\n        uint256 _value\\n    )\\n        public\\n        onlyAfterLockup\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            allowed[_from][msg.sender] >= _value,\\n            \\\"ETHMaxiToken: not enough allowance\\\"\\n        );\\n\\n        require(\\n            balances[_from] >= _value,\\n            \\\"ETHMaxiToken: owner account doesn't have enough balance to make this transfer\\\"\\n        );\\n\\n        balances[_to] += _value;\\n        balances[_from] -= _value;\\n        allowed[_from][msg.sender] -= _value;\\n        emit Transfer(_from, _to, _value);\\n        return true;\\n    }\\n\\n    function balanceOf(\\n        address _owner\\n    )\\n        public\\n        view\\n        returns (\\n            uint256\\n        )\\n    {\\n        return balances[_owner];\\n    }\\n\\n    function approve(\\n        address _spender,\\n        uint256 _value\\n    )\\n        public\\n        returns (\\n            bool\\n        )\\n    {\\n        allowed[msg.sender][_spender] = _value;\\n        emit Approval(msg.sender, _spender, _value);\\n        return true;\\n    }\\n\\n    function allowance(\\n        address _owner,\\n        address _spender\\n    )\\n        public\\n        view\\n        returns (\\n            uint256\\n        )\\n    {\\n        return allowed[_owner][_spender];\\n    }\\n}\\n\",\"keccak256\":\"0xad1de529233771461af1e8e2bd218a4f7069d5f7c0c57db92e03912fc8dffc03\",\"license\":\"MIT\"},\"contracts/libraries/Lib_BytesUtils.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_BytesUtils\\n */\\nlibrary Lib_BytesUtils {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_length + 31 >= _length, \\\"slice_overflow\\\");\\n        require(_start + _length >= _start, \\\"slice_overflow\\\");\\n        require(_bytes.length >= _start + _length, \\\"slice_outOfBounds\\\");\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                //zero out the 32 bytes slice we are about to return\\n                //we need to do it because Solidity does not garbage collect\\n                mstore(tempBytes, 0)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        if (_bytes.length - _start == 0) {\\n            return bytes('');\\n        }\\n\\n        return slice(_bytes, _start, _bytes.length - _start);\\n    }\\n\\n    function toBytes32PadLeft(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        bytes32 ret;\\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\\n        assembly {\\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\\n        }\\n        return ret;\\n    }\\n\\n    function toBytes32(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes32)\\n    {\\n        if (_bytes.length < 32) {\\n            bytes32 ret;\\n            assembly {\\n                ret := mload(add(_bytes, 32))\\n            }\\n            return ret;\\n        }\\n\\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\\n    }\\n\\n    function toUint256(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (uint256)\\n    {\\n        return uint256(toBytes32(_bytes));\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, \\\"toUint24_overflow\\\");\\n        require(_bytes.length >= _start + 3 , \\\"toUint24_outOfBounds\\\");\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\\n        require(_start + 1 >= _start, \\\"toUint8_overflow\\\");\\n        require(_bytes.length >= _start + 1 , \\\"toUint8_outOfBounds\\\");\\n        uint8 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x1), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, \\\"toAddress_overflow\\\");\\n        require(_bytes.length >= _start + 20, \\\"toAddress_outOfBounds\\\");\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory nibbles = new bytes(_bytes.length * 2);\\n\\n        for (uint256 i = 0; i < _bytes.length; i++) {\\n            nibbles[i * 2] = _bytes[i] >> 4;\\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\\n        }\\n\\n        return nibbles;\\n    }\\n\\n    function fromNibbles(\\n        bytes memory _bytes\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        bytes memory ret = new bytes(_bytes.length / 2);\\n\\n        for (uint256 i = 0; i < ret.length; i++) {\\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\\n        }\\n\\n        return ret;\\n    }\\n\\n    function equal(\\n        bytes memory _bytes,\\n        bytes memory _other\\n    )\\n        internal\\n        pure\\n        returns (bool)\\n    {\\n        return keccak256(_bytes) == keccak256(_other);\\n    }\\n}\\n\",\"keccak256\":\"0x0adf22e1b22ba09911e859f64cb3b484e992be4f9fd3b09088e6225bf8d06ce0\",\"license\":\"MIT\"},\"contracts/libraries/Lib_EIP155Tx.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_RLPReader } from \\\"./Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"./Lib_RLPWriter.sol\\\";\\n\\n/**\\n * @title Lib_EIP155Tx\\n * @dev A simple library for dealing with the transaction type defined by EIP155:\\n *      https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\\n */\\nlibrary Lib_EIP155Tx {\\n\\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    // Struct representing an EIP155 transaction. See EIP link above for more information.\\n    struct EIP155Tx {\\n        // These fields correspond to the actual RLP-encoded fields specified by EIP155.\\n        uint256 nonce;\\n        uint256 gasPrice;\\n        uint256 gasLimit;\\n        address to;\\n        uint256 value;\\n        bytes data;\\n        uint8 v;\\n        bytes32 r;\\n        bytes32 s;\\n\\n        // Chain ID to associate this transaction with. Used all over the place, seemed easier to\\n        // set this once when we create the transaction rather than providing it as an input to\\n        // each function. I don't see a strong need to have a transaction with a mutable chain ID.\\n        uint256 chainId;\\n\\n        // The ECDSA \\\"recovery parameter,\\\" should always be 0 or 1. EIP155 specifies that:\\n        // `v = {0,1} + CHAIN_ID * 2 + 35`\\n        // Where `{0,1}` is a stand in for our `recovery_parameter`. Now computing our formula for\\n        // the recovery parameter:\\n        // 1. `v = {0,1} + CHAIN_ID * 2 + 35`\\n        // 2. `v = recovery_parameter + CHAIN_ID * 2 + 35`\\n        // 3. `v - CHAIN_ID * 2 - 35 = recovery_parameter`\\n        // So we're left with the final formula:\\n        // `recovery_parameter = v - CHAIN_ID * 2 - 35`\\n        // NOTE: This variable is a uint8 because `v` is inherently limited to a uint8. If we\\n        // didn't use a uint8, then recovery_parameter would always be a negative number for chain\\n        // IDs greater than 110 (`255 - 110 * 2 - 35 = 0`). So we need to wrap around to support\\n        // anything larger.\\n        uint8 recoveryParam; \\n\\n        // Whether or not the transaction is a creation. Necessary because we can't make an address\\n        // \\\"nil\\\". Using the zero address creates a potential conflict if the user did actually\\n        // intend to send a transaction to the zero address.\\n        bool isCreate;       \\n    }\\n\\n    // Lets us use nicer syntax.\\n    using Lib_EIP155Tx for EIP155Tx;\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * Decodes an EIP155 transaction and attaches a given Chain ID.\\n     * Transaction *must* be RLP-encoded.\\n     * @param _encoded RLP-encoded EIP155 transaction.\\n     * @param _chainId Chain ID to assocaite with this transaction.\\n     * @return Parsed transaction.\\n     */\\n    function decode(\\n        bytes memory _encoded,\\n        uint256 _chainId\\n    )\\n        internal\\n        pure\\n        returns (\\n            EIP155Tx memory\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_encoded);\\n\\n        // Note formula above about how recoveryParam is computed.\\n        uint8 v = uint8(Lib_RLPReader.readUint256(decoded[6]));\\n        uint8 recoveryParam = uint8(v - 2 * _chainId - 35);\\n\\n        require(\\n            recoveryParam < 2,\\n            \\\"Lib_EIP155Tx: invalid chain id\\\"\\n        );\\n\\n        // Creations can be detected by looking at the byte length here.\\n        bool isCreate = Lib_RLPReader.readBytes(decoded[3]).length == 0;\\n\\n        return EIP155Tx({\\n            nonce: Lib_RLPReader.readUint256(decoded[0]),\\n            gasPrice: Lib_RLPReader.readUint256(decoded[1]),\\n            gasLimit: Lib_RLPReader.readUint256(decoded[2]),\\n            to: Lib_RLPReader.readAddress(decoded[3]),\\n            value: Lib_RLPReader.readUint256(decoded[4]),\\n            data: Lib_RLPReader.readBytes(decoded[5]),\\n            v: v,\\n            r: Lib_RLPReader.readBytes32(decoded[7]),\\n            s: Lib_RLPReader.readBytes32(decoded[8]),\\n            chainId: _chainId,\\n            recoveryParam: recoveryParam,\\n            isCreate: isCreate\\n        });\\n    }\\n\\n    /**\\n     * Encodes an EIP155 transaction into RLP.\\n     * @param _transaction EIP155 transaction to encode.\\n     * @param _includeSignature Whether or not to encode the signature.\\n     * @return RLP-encoded transaction.\\n     */\\n    function encode(\\n        EIP155Tx memory _transaction,\\n        bool _includeSignature\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](9);\\n\\n        raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\\n        raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\\n        raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\\n\\n        // We write the encoding of empty bytes when the transaction is a creation, *not* the zero\\n        // address as one might assume.\\n        if (_transaction.isCreate) {\\n            raw[3] = Lib_RLPWriter.writeBytes('');\\n        } else {\\n            raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\\n        }\\n\\n        raw[4] = Lib_RLPWriter.writeUint(_transaction.value);\\n        raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\\n\\n        if (_includeSignature) {\\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.v);\\n            raw[7] = Lib_RLPWriter.writeBytes32(_transaction.r);\\n            raw[8] = Lib_RLPWriter.writeBytes32(_transaction.s);\\n        } else {\\n            // Chain ID *is* included in the unsigned transaction.\\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId); \\n            raw[7] = Lib_RLPWriter.writeBytes('');\\n            raw[8] = Lib_RLPWriter.writeBytes('');\\n        }\\n\\n        return Lib_RLPWriter.writeList(raw);\\n    }\\n\\n    /**\\n     * Computes the hash of an EIP155 transaction. Assumes that you don't want to include the\\n     * signature in this hash because that's a very uncommon usecase. If you really want to include\\n     * the signature, just encode with the signature and take the hash yourself.\\n     */\\n    function hash(\\n        EIP155Tx memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return keccak256(\\n            _transaction.encode(false)\\n        );\\n    }\\n\\n    /**\\n     * Computes the sender of an EIP155 transaction.\\n     * @param _transaction EIP155 transaction to get a sender for.\\n     * @return Address corresponding to the private key that signed this transaction.\\n     */\\n    function sender(\\n        EIP155Tx memory _transaction\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return ecrecover(\\n            _transaction.hash(),\\n            _transaction.recoveryParam + 27,\\n            _transaction.r,\\n            _transaction.s\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0xefc8d91f75418dc02e78b6be19a447b119b64f80914603311d701a9f333e3777\",\"license\":\"MIT\"},\"contracts/libraries/Lib_MerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"./Lib_BytesUtils.sol\\\";\\nimport { Lib_RLPReader } from \\\"./Lib_RLPReader.sol\\\";\\nimport { Lib_RLPWriter } from \\\"./Lib_RLPWriter.sol\\\";\\n\\n/**\\n * @title Lib_MerkleTrie\\n */\\nlibrary Lib_MerkleTrie {\\n\\n    /*******************\\n     * Data Structures *\\n     *******************/\\n\\n    enum NodeType {\\n        BranchNode,\\n        ExtensionNode,\\n        LeafNode\\n    }\\n\\n    struct TrieNode {\\n        bytes encoded;\\n        Lib_RLPReader.RLPItem[] decoded;\\n    }\\n\\n\\n    /**********************\\n     * Contract Constants *\\n     **********************/\\n\\n    // TREE_RADIX determines the number of elements per branch node.\\n    uint256 constant TREE_RADIX = 16;\\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\\n\\n    // Prefixes are prepended to the `path` within a leaf or extension node and\\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\\n    // determined by the number of nibbles within the unprefixed `path`. If the\\n    // number of nibbles if even, we need to insert an extra padding nibble so\\n    // the resulting prefixed `path` has an even number of nibbles.\\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\\n    uint8 constant PREFIX_LEAF_EVEN = 2;\\n    uint8 constant PREFIX_LEAF_ODD = 3;\\n\\n    // Just a utility constant. RLP represents `NULL` as 0x80.\\n    bytes1 constant RLP_NULL = bytes1(0x80);\\n    bytes constant RLP_NULL_BYTES = hex'80';\\n    bytes32 constant internal KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);\\n\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _verified\\n        )\\n    {\\n        (\\n            bool exists,\\n            bytes memory value\\n        ) = get(_key, _proof, _root);\\n\\n        return (\\n            exists && Lib_BytesUtils.equal(_value, value)\\n        );\\n    }\\n\\n    /**\\n     * @notice Verifies a proof that a given key is *not* present in\\n     * the Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the key is absent in the trie, `false` otherwise.\\n     */\\n    function verifyExclusionProof(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _verified\\n        )\\n    {\\n        (\\n            bool exists,\\n        ) = get(_key, _proof, _root);\\n\\n        return exists == false;\\n    }\\n\\n    /**\\n     * @notice Updates a Merkle trie and returns a new root hash.\\n     * @param _key Key of the node to update, as a hex string.\\n     * @param _value Value of the node to update, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node. If the key exists, we can simply update the value.\\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _updatedRoot Root hash of the newly constructed trie.\\n     */\\n    function update(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _updatedRoot\\n        )\\n    {\\n        // Special case when inserting the very first node.\\n        if (_root == KECCAK256_RLP_NULL_BYTES) {\\n            return getSingleNodeRootHash(_key, _value);\\n        }\\n\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);\\n        TrieNode[] memory newPath = _getNewPath(proof, pathLength, keyRemainder, _value);\\n\\n        return _getUpdatedTrieRoot(newPath, _key);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _exists,\\n            bytes memory _value\\n        )\\n    {\\n        TrieNode[] memory proof = _parseProof(_proof);\\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(proof, _key, _root);\\n\\n        bool exists = keyRemainder.length == 0;\\n\\n        require(\\n            exists || isFinalNode,\\n            \\\"Provided proof is invalid.\\\"\\n        );\\n\\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes('');\\n\\n        return (\\n            exists,\\n            value\\n        );\\n    }\\n\\n    /**\\n     * Computes the root hash for a trie with a single node.\\n     * @param _key Key for the single node.\\n     * @param _value Value for the single node.\\n     * @return _updatedRoot Hash of the trie.\\n     */\\n    function getSingleNodeRootHash(\\n        bytes memory _key,\\n        bytes memory _value\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _updatedRoot\\n        )\\n    {\\n        return keccak256(_makeLeafNode(\\n            Lib_BytesUtils.toNibbles(_key),\\n            _value\\n        ).encoded);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * @notice Walks through a proof using a provided key.\\n     * @param _proof Inclusion proof to walk through.\\n     * @param _key Key to use for the walk.\\n     * @param _root Known root of the trie.\\n     * @return _pathLength Length of the final path\\n     * @return _keyRemainder Portion of the key remaining after the walk.\\n     * @return _isFinalNode Whether or not we've hit a dead end.\\n     */\\n    function _walkNodePath(\\n        TrieNode[] memory _proof,\\n        bytes memory _key,\\n        bytes32 _root\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256 _pathLength,\\n            bytes memory _keyRemainder,\\n            bool _isFinalNode\\n        )\\n    {\\n        uint256 pathLength = 0;\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        bytes32 currentNodeID = _root;\\n        uint256 currentKeyIndex = 0;\\n        uint256 currentKeyIncrement = 0;\\n        TrieNode memory currentNode;\\n\\n        // Proof is top-down, so we start at the first element (root).\\n        for (uint256 i = 0; i < _proof.length; i++) {\\n            currentNode = _proof[i];\\n            currentKeyIndex += currentKeyIncrement;\\n\\n            // Keep track of the proof elements we actually need.\\n            // It's expensive to resize arrays, so this simply reduces gas costs.\\n            pathLength += 1;\\n\\n            if (currentKeyIndex == 0) {\\n                // First proof element is always the root node.\\n                require(\\n                    keccak256(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid root hash\\\"\\n                );\\n            } else if (currentNode.encoded.length >= 32) {\\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\\n                require(\\n                    keccak256(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid large internal hash\\\"\\n                );\\n            } else {\\n                // Nodes smaller than 31 bytes aren't hashed.\\n                require(\\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\\n                    \\\"Invalid internal node hash\\\"\\n                );\\n            }\\n\\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\\n                if (currentKeyIndex == key.length) {\\n                    // We've hit the end of the key, meaning the value should be within this branch node.\\n                    break;\\n                } else {\\n                    // We're not at the end of the key yet.\\n                    // Figure out what the next node ID should be and continue.\\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\\n                    currentNodeID = _getNodeID(nextNode);\\n                    currentKeyIncrement = 1;\\n                    continue;\\n                }\\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n                bytes memory path = _getNodePath(currentNode);\\n                uint8 prefix = uint8(path[0]);\\n                uint8 offset = 2 - prefix % 2;\\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\\n\\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                    if (\\n                        pathRemainder.length == sharedNibbleLength &&\\n                        keyRemainder.length == sharedNibbleLength\\n                    ) {\\n                        // The key within this leaf matches our key exactly.\\n                        // Increment the key index to reflect that we have no remainder.\\n                        currentKeyIndex += sharedNibbleLength;\\n                    }\\n\\n                    // We've hit a leaf node, so our next node should be NULL.\\n                    currentNodeID = bytes32(RLP_NULL);\\n                    break;\\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                    if (sharedNibbleLength == 0) {\\n                        // Our extension node doesn't share any part of our key.\\n                        // We've hit the end of this path, updates will need to modify this extension.\\n                        currentNodeID = bytes32(RLP_NULL);\\n                        break;\\n                    } else {\\n                        // Our extension shares some nibbles.\\n                        // Carry on to the next node.\\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\\n                        currentKeyIncrement = sharedNibbleLength;\\n                        continue;\\n                    }\\n                } else {\\n                    revert(\\\"Received a node with an unknown prefix\\\");\\n                }\\n            } else {\\n                revert(\\\"Received an unparseable node.\\\");\\n            }\\n        }\\n\\n        // If our node ID is NULL, then we're at a dead end.\\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\\n    }\\n\\n    /**\\n     * @notice Creates new nodes to support a k/v pair insertion into a given\\n     * Merkle trie path.\\n     * @param _path Path to the node nearest the k/v pair.\\n     * @param _pathLength Length of the path. Necessary because the provided\\n     * path may include additional nodes (e.g., it comes directly from a proof)\\n     * and we can't resize in-memory arrays without costly duplication.\\n     * @param _keyRemainder Portion of the initial key that must be inserted\\n     * into the trie.\\n     * @param _value Value to insert at the given key.\\n     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.\\n     */\\n    function _getNewPath(\\n        TrieNode[] memory _path,\\n        uint256 _pathLength,\\n        bytes memory _keyRemainder,\\n        bytes memory _value\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode[] memory _newPath\\n        )\\n    {\\n        bytes memory keyRemainder = _keyRemainder;\\n\\n        // Most of our logic depends on the status of the last node in the path.\\n        TrieNode memory lastNode = _path[_pathLength - 1];\\n        NodeType lastNodeType = _getNodeType(lastNode);\\n\\n        // Create an array for newly created nodes.\\n        // We need up to three new nodes, depending on the contents of the last node.\\n        // Since array resizing is expensive, we'll keep track of the size manually.\\n        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.\\n        TrieNode[] memory newNodes = new TrieNode[](3);\\n        uint256 totalNewNodes = 0;\\n\\n        if (keyRemainder.length == 0 && lastNodeType == NodeType.LeafNode) {\\n            // We've found a leaf node with the given key.\\n            // Simply need to update the value of the node to match.\\n            newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);\\n            totalNewNodes += 1;\\n        } else if (lastNodeType == NodeType.BranchNode) {\\n            if (keyRemainder.length == 0) {\\n                // We've found a branch node with the given key.\\n                // Simply need to update the value of the node to match.\\n                newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);\\n                totalNewNodes += 1;\\n            } else {\\n                // We've found a branch node, but it doesn't contain our key.\\n                // Reinsert the old branch for now.\\n                newNodes[totalNewNodes] = lastNode;\\n                totalNewNodes += 1;\\n                // Create a new leaf node, slicing our remainder since the first byte points\\n                // to our branch node.\\n                newNodes[totalNewNodes] = _makeLeafNode(Lib_BytesUtils.slice(keyRemainder, 1), _value);\\n                totalNewNodes += 1;\\n            }\\n        } else {\\n            // Our last node is either an extension node or a leaf node with a different key.\\n            bytes memory lastNodeKey = _getNodeKey(lastNode);\\n            uint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);\\n\\n            if (sharedNibbleLength != 0) {\\n                // We've got some shared nibbles between the last node and our key remainder.\\n                // We'll need to insert an extension node that covers these shared nibbles.\\n                bytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);\\n                newNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));\\n                totalNewNodes += 1;\\n\\n                // Cut down the keys since we've just covered these shared nibbles.\\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);\\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);\\n            }\\n\\n            // Create an empty branch to fill in.\\n            TrieNode memory newBranch = _makeEmptyBranchNode();\\n\\n            if (lastNodeKey.length == 0) {\\n                // Key remainder was larger than the key for our last node.\\n                // The value within our last node is therefore going to be shifted into\\n                // a branch value slot.\\n                newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));\\n            } else {\\n                // Last node key was larger than the key remainder.\\n                // We're going to modify some index of our branch.\\n                uint8 branchKey = uint8(lastNodeKey[0]);\\n                // Move on to the next nibble.\\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);\\n\\n                if (lastNodeType == NodeType.LeafNode) {\\n                    // We're dealing with a leaf node.\\n                    // We'll modify the key and insert the old leaf node into the branch index.\\n                    TrieNode memory modifiedLastNode = _makeLeafNode(lastNodeKey, _getNodeValue(lastNode));\\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeHash(modifiedLastNode.encoded));\\n                } else if (lastNodeKey.length != 0) {\\n                    // We're dealing with a shrinking extension node.\\n                    // We need to modify the node to decrease the size of the key.\\n                    TrieNode memory modifiedLastNode = _makeExtensionNode(lastNodeKey, _getNodeValue(lastNode));\\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeHash(modifiedLastNode.encoded));\\n                } else {\\n                    // We're dealing with an unnecessary extension node.\\n                    // We're going to delete the node entirely.\\n                    // Simply insert its current value into the branch index.\\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));\\n                }\\n            }\\n\\n            if (keyRemainder.length == 0) {\\n                // We've got nothing left in the key remainder.\\n                // Simply insert the value into the branch value slot.\\n                newBranch = _editBranchValue(newBranch, _value);\\n                // Push the branch into the list of new nodes.\\n                newNodes[totalNewNodes] = newBranch;\\n                totalNewNodes += 1;\\n            } else {\\n                // We've got some key remainder to work with.\\n                // We'll be inserting a leaf node into the trie.\\n                // First, move on to the next nibble.\\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);\\n                // Push the branch into the list of new nodes.\\n                newNodes[totalNewNodes] = newBranch;\\n                totalNewNodes += 1;\\n                // Push a new leaf node for our k/v pair.\\n                newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);\\n                totalNewNodes += 1;\\n            }\\n        }\\n\\n        // Finally, join the old path with our newly created nodes.\\n        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.\\n        return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);\\n    }\\n\\n    /**\\n     * @notice Computes the trie root from a given path.\\n     * @param _nodes Path to some k/v pair.\\n     * @param _key Key for the k/v pair.\\n     * @return _updatedRoot Root hash for the updated trie.\\n     */\\n    function _getUpdatedTrieRoot(\\n        TrieNode[] memory _nodes,\\n        bytes memory _key\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes32 _updatedRoot\\n        )\\n    {\\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\\n\\n        // Some variables to keep track of during iteration.\\n        TrieNode memory currentNode;\\n        NodeType currentNodeType;\\n        bytes memory previousNodeHash;\\n\\n        // Run through the path backwards to rebuild our root hash.\\n        for (uint256 i = _nodes.length; i > 0; i--) {\\n            // Pick out the current node.\\n            currentNode = _nodes[i - 1];\\n            currentNodeType = _getNodeType(currentNode);\\n\\n            if (currentNodeType == NodeType.LeafNode) {\\n                // Leaf nodes are already correctly encoded.\\n                // Shift the key over to account for the nodes key.\\n                bytes memory nodeKey = _getNodeKey(currentNode);\\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n            } else if (currentNodeType == NodeType.ExtensionNode) {\\n                // Shift the key over to account for the nodes key.\\n                bytes memory nodeKey = _getNodeKey(currentNode);\\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\\n\\n                // If this node is the last element in the path, it'll be correctly encoded\\n                // and we can skip this part.\\n                if (previousNodeHash.length > 0) {\\n                    // Re-encode the node based on the previous node.\\n                    currentNode = _makeExtensionNode(nodeKey, previousNodeHash);\\n                }\\n            } else if (currentNodeType == NodeType.BranchNode) {\\n                // If this node is the last element in the path, it'll be correctly encoded\\n                // and we can skip this part.\\n                if (previousNodeHash.length > 0) {\\n                    // Re-encode the node based on the previous node.\\n                    uint8 branchKey = uint8(key[key.length - 1]);\\n                    key = Lib_BytesUtils.slice(key, 0, key.length - 1);\\n                    currentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);\\n                }\\n            }\\n\\n            // Compute the node hash for the next iteration.\\n            previousNodeHash = _getNodeHash(currentNode.encoded);\\n        }\\n\\n        // Current node should be the root at this point.\\n        // Simply return the hash of its encoding.\\n        return keccak256(currentNode.encoded);\\n    }\\n\\n    /**\\n     * @notice Parses an RLP-encoded proof into something more useful.\\n     * @param _proof RLP-encoded proof to parse.\\n     * @return _parsed Proof parsed into easily accessible structs.\\n     */\\n    function _parseProof(\\n        bytes memory _proof\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode[] memory _parsed\\n        )\\n    {\\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\\n\\n        for (uint256 i = 0; i < nodes.length; i++) {\\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\\n            proof[i] = TrieNode({\\n                encoded: encoded,\\n                decoded: Lib_RLPReader.readList(encoded)\\n            });\\n        }\\n\\n        return proof;\\n    }\\n\\n    /**\\n     * @notice Picks out the ID for a node. Node ID is referred to as the\\n     * \\\"hash\\\" within the specification, but nodes < 32 bytes are not actually\\n     * hashed.\\n     * @param _node Node to pull an ID for.\\n     * @return _nodeID ID for the node, depending on the size of its contents.\\n     */\\n    function _getNodeID(\\n        Lib_RLPReader.RLPItem memory _node\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes32 _nodeID\\n        )\\n    {\\n        bytes memory nodeID;\\n\\n        if (_node.length < 32) {\\n            // Nodes smaller than 32 bytes are RLP encoded.\\n            nodeID = Lib_RLPReader.readRawBytes(_node);\\n        } else {\\n            // Nodes 32 bytes or larger are hashed.\\n            nodeID = Lib_RLPReader.readBytes(_node);\\n        }\\n\\n        return Lib_BytesUtils.toBytes32(nodeID);\\n    }\\n\\n    /**\\n     * @notice Gets the path for a leaf or extension node.\\n     * @param _node Node to get a path for.\\n     * @return _path Node path, converted to an array of nibbles.\\n     */\\n    function _getNodePath(\\n        TrieNode memory _node\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _path\\n        )\\n    {\\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\\n    }\\n\\n    /**\\n     * @notice Gets the key for a leaf or extension node. Keys are essentially\\n     * just paths without any prefix.\\n     * @param _node Node to get a key for.\\n     * @return _key Node key, converted to an array of nibbles.\\n     */\\n    function _getNodeKey(\\n        TrieNode memory _node\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _key\\n        )\\n    {\\n        return _removeHexPrefix(_getNodePath(_node));\\n    }\\n\\n    /**\\n     * @notice Gets the path for a node.\\n     * @param _node Node to get a value for.\\n     * @return _value Node value, as hex bytes.\\n     */\\n    function _getNodeValue(\\n        TrieNode memory _node\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _value\\n        )\\n    {\\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\\n    }\\n\\n    /**\\n     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes\\n     * are not hashed, all others are keccak256 hashed.\\n     * @param _encoded Encoded node to hash.\\n     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.\\n     */\\n    function _getNodeHash(\\n        bytes memory _encoded\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _hash\\n        )\\n    {\\n        if (_encoded.length < 32) {\\n            return _encoded;\\n        } else {\\n            return abi.encodePacked(keccak256(_encoded));\\n        }\\n    }\\n\\n    /**\\n     * @notice Determines the type for a given node.\\n     * @param _node Node to determine a type for.\\n     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.\\n     */\\n    function _getNodeType(\\n        TrieNode memory _node\\n    )\\n        private\\n        pure\\n        returns (\\n            NodeType _type\\n        )\\n    {\\n        if (_node.decoded.length == BRANCH_NODE_LENGTH) {\\n            return NodeType.BranchNode;\\n        } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\\n            bytes memory path = _getNodePath(_node);\\n            uint8 prefix = uint8(path[0]);\\n\\n            if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\\n                return NodeType.LeafNode;\\n            } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\\n                return NodeType.ExtensionNode;\\n            }\\n        }\\n\\n        revert(\\\"Invalid node type\\\");\\n    }\\n\\n    /**\\n     * @notice Utility; determines the number of nibbles shared between two\\n     * nibble arrays.\\n     * @param _a First nibble array.\\n     * @param _b Second nibble array.\\n     * @return _shared Number of shared nibbles.\\n     */\\n    function _getSharedNibbleLength(\\n        bytes memory _a,\\n        bytes memory _b\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256 _shared\\n        )\\n    {\\n        uint256 i = 0;\\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\\n            i++;\\n        }\\n        return i;\\n    }\\n\\n    /**\\n     * @notice Utility; converts an RLP-encoded node into our nice struct.\\n     * @param _raw RLP-encoded node to convert.\\n     * @return _node Node as a TrieNode struct.\\n     */\\n    function _makeNode(\\n        bytes[] memory _raw\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _node\\n        )\\n    {\\n        bytes memory encoded = Lib_RLPWriter.writeList(_raw);\\n\\n        return TrieNode({\\n            encoded: encoded,\\n            decoded: Lib_RLPReader.readList(encoded)\\n        });\\n    }\\n\\n    /**\\n     * @notice Utility; converts an RLP-decoded node into our nice struct.\\n     * @param _items RLP-decoded node to convert.\\n     * @return _node Node as a TrieNode struct.\\n     */\\n    function _makeNode(\\n        Lib_RLPReader.RLPItem[] memory _items\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _node\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](_items.length);\\n        for (uint256 i = 0; i < _items.length; i++) {\\n            raw[i] = Lib_RLPReader.readRawBytes(_items[i]);\\n        }\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates a new extension node.\\n     * @param _key Key for the extension node, unprefixed.\\n     * @param _value Value for the extension node.\\n     * @return _node New extension node with the given k/v pair.\\n     */\\n    function _makeExtensionNode(\\n        bytes memory _key,\\n        bytes memory _value\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _node\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](2);\\n        bytes memory key = _addHexPrefix(_key, false);\\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates a new leaf node.\\n     * @dev This function is essentially identical to `_makeExtensionNode`.\\n     * Although we could route both to a single method with a flag, it's\\n     * more gas efficient to keep them separate and duplicate the logic.\\n     * @param _key Key for the leaf node, unprefixed.\\n     * @param _value Value for the leaf node.\\n     * @return _node New leaf node with the given k/v pair.\\n     */\\n    function _makeLeafNode(\\n        bytes memory _key,\\n        bytes memory _value\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _node\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](2);\\n        bytes memory key = _addHexPrefix(_key, true);\\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Creates an empty branch node.\\n     * @return _node Empty branch node as a TrieNode struct.\\n     */\\n    function _makeEmptyBranchNode()\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _node\\n        )\\n    {\\n        bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);\\n        for (uint256 i = 0; i < raw.length; i++) {\\n            raw[i] = RLP_NULL_BYTES;\\n        }\\n        return _makeNode(raw);\\n    }\\n\\n    /**\\n     * @notice Modifies the value slot for a given branch.\\n     * @param _branch Branch node to modify.\\n     * @param _value Value to insert into the branch.\\n     * @return _updatedNode Modified branch node.\\n     */\\n    function _editBranchValue(\\n        TrieNode memory _branch,\\n        bytes memory _value\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _updatedNode\\n        )\\n    {\\n        bytes memory encoded = Lib_RLPWriter.writeBytes(_value);\\n        _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);\\n        return _makeNode(_branch.decoded);\\n    }\\n\\n    /**\\n     * @notice Modifies a slot at an index for a given branch.\\n     * @param _branch Branch node to modify.\\n     * @param _index Slot index to modify.\\n     * @param _value Value to insert into the slot.\\n     * @return _updatedNode Modified branch node.\\n     */\\n    function _editBranchIndex(\\n        TrieNode memory _branch,\\n        uint8 _index,\\n        bytes memory _value\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode memory _updatedNode\\n        )\\n    {\\n        bytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);\\n        _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);\\n        return _makeNode(_branch.decoded);\\n    }\\n\\n    /**\\n     * @notice Utility; adds a prefix to a key.\\n     * @param _key Key to prefix.\\n     * @param _isLeaf Whether or not the key belongs to a leaf.\\n     * @return _prefixedKey Prefixed key.\\n     */\\n    function _addHexPrefix(\\n        bytes memory _key,\\n        bool _isLeaf\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _prefixedKey\\n        )\\n    {\\n        uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);\\n        uint8 offset = uint8(_key.length % 2);\\n        bytes memory prefixed = new bytes(2 - offset);\\n        prefixed[0] = bytes1(prefix + offset);\\n        return abi.encodePacked(prefixed, _key);\\n    }\\n\\n    /**\\n     * @notice Utility; removes a prefix from a path.\\n     * @param _path Path to remove the prefix from.\\n     * @return _unprefixedKey Unprefixed key.\\n     */\\n    function _removeHexPrefix(\\n        bytes memory _path\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _unprefixedKey\\n        )\\n    {\\n        if (uint8(_path[0]) % 2 == 0) {\\n            return Lib_BytesUtils.slice(_path, 2);\\n        } else {\\n            return Lib_BytesUtils.slice(_path, 1);\\n        }\\n    }\\n\\n    /**\\n     * @notice Utility; combines two node arrays. Array lengths are required\\n     * because the actual lengths may be longer than the filled lengths.\\n     * Array resizing is extremely costly and should be avoided.\\n     * @param _a First array to join.\\n     * @param _aLength Length of the first array.\\n     * @param _b Second array to join.\\n     * @param _bLength Length of the second array.\\n     * @return _joined Combined node array.\\n     */\\n    function _joinNodeArrays(\\n        TrieNode[] memory _a,\\n        uint256 _aLength,\\n        TrieNode[] memory _b,\\n        uint256 _bLength\\n    )\\n        private\\n        pure\\n        returns (\\n            TrieNode[] memory _joined\\n        )\\n    {\\n        TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);\\n\\n        // Copy elements from the first array.\\n        for (uint256 i = 0; i < _aLength; i++) {\\n            ret[i] = _a[i];\\n        }\\n\\n        // Copy elements from the second array.\\n        for (uint256 i = 0; i < _bLength; i++) {\\n            ret[i + _aLength] = _b[i];\\n        }\\n\\n        return ret;\\n    }\\n}\\n\",\"keccak256\":\"0x3aafa6bc3e3436d30ed94eefc7d0900976296f1379eab888cc7617b74af3cc0e\",\"license\":\"MIT\"},\"contracts/libraries/Lib_RLPReader.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\n\\n/**\\n * @title Lib_RLPReader\\n * @dev Adapted from \\\"RLPReader\\\" by Hamdi Allam (hamdi.allam97@gmail.com).\\n */\\nlibrary Lib_RLPReader {\\n\\n    /*************\\n     * Constants *\\n     *************/\\n\\n    uint256 constant internal MAX_LIST_LENGTH = 32;\\n\\n\\n    /*********\\n     * Enums *\\n     *********/\\n\\n    enum RLPItemType {\\n        DATA_ITEM,\\n        LIST_ITEM\\n    }\\n\\n    \\n    /***********\\n     * Structs *\\n     ***********/\\n\\n    struct RLPItem {\\n        uint256 length;\\n        uint256 ptr;\\n    }\\n    \\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n    \\n    /**\\n     * Converts bytes to a reference to memory position and length.\\n     * @param _in Input bytes to convert.\\n     * @return Output memory reference.\\n     */\\n    function toRLPItem(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem memory\\n        )\\n    {\\n        uint256 ptr;\\n        assembly {\\n            ptr := add(_in, 32)\\n        }\\n\\n        return RLPItem({\\n            length: _in.length,\\n            ptr: ptr\\n        });\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        (\\n            uint256 listOffset,\\n            ,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.LIST_ITEM,\\n            \\\"Invalid RLP list value.\\\"\\n        );\\n\\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\\n        // writing to the length. Since we can't know the number of RLP items without looping over\\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\\n        // simply set a reasonable maximum list length and decrease the size before we finish.\\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\\n\\n        uint256 itemCount = 0;\\n        uint256 offset = listOffset;\\n        while (offset < _in.length) {\\n            require(\\n                itemCount < MAX_LIST_LENGTH,\\n                \\\"Provided RLP list exceeds max list length.\\\"\\n            );\\n\\n            (\\n                uint256 itemOffset,\\n                uint256 itemLength,\\n            ) = _decodeLength(RLPItem({\\n                length: _in.length - offset,\\n                ptr: _in.ptr + offset\\n            }));\\n\\n            out[itemCount] = RLPItem({\\n                length: itemLength + itemOffset,\\n                ptr: _in.ptr + offset\\n            });\\n\\n            itemCount += 1;\\n            offset += itemOffset + itemLength;\\n        }\\n\\n        // Decrease the array size to match the actual item count.\\n        assembly {\\n            mstore(out, itemCount)\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP list value into a list of RLP items.\\n     * @param _in RLP list value.\\n     * @return Decoded RLP list items.\\n     */\\n    function readList(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            RLPItem[] memory\\n        )\\n    {\\n        return readList(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes value.\\\"\\n        );\\n\\n        return _copy(_in.ptr, itemOffset, itemLength);\\n    }\\n\\n    /**\\n     * Reads an RLP bytes value into bytes.\\n     * @param _in RLP bytes value.\\n     * @return Decoded bytes.\\n     */\\n    function readBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return readBytes(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return string(readBytes(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP string value into a string.\\n     * @param _in RLP string value.\\n     * @return Decoded string.\\n     */\\n    function readString(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            string memory\\n        )\\n    {\\n        return readString(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        require(\\n            _in.length <= 33,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        (\\n            uint256 itemOffset,\\n            uint256 itemLength,\\n            RLPItemType itemType\\n        ) = _decodeLength(_in);\\n\\n        require(\\n            itemType == RLPItemType.DATA_ITEM,\\n            \\\"Invalid RLP bytes32 value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr + itemOffset;\\n        bytes32 out;\\n        assembly {\\n            out := mload(ptr)\\n\\n            // Shift the bytes over to match the item size.\\n            if lt(itemLength, 32) {\\n                out := div(out, exp(256, sub(32, itemLength)))\\n            }\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Reads an RLP bytes32 value into a bytes32.\\n     * @param _in RLP bytes32 value.\\n     * @return Decoded bytes32.\\n     */\\n    function readBytes32(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32\\n        )\\n    {\\n        return readBytes32(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return uint256(readBytes32(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP uint256 value into a uint256.\\n     * @param _in RLP uint256 value.\\n     * @return Decoded uint256.\\n     */\\n    function readUint256(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            uint256\\n        )\\n    {\\n        return readUint256(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        require(\\n            _in.length == 1,\\n            \\\"Invalid RLP boolean value.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 out;\\n        assembly {\\n            out := byte(0, mload(ptr))\\n        }\\n\\n        return out != 0;\\n    }\\n\\n    /**\\n     * Reads an RLP bool value into a bool.\\n     * @param _in RLP bool value.\\n     * @return Decoded bool.\\n     */\\n    function readBool(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool\\n        )\\n    {\\n        return readBool(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        if (_in.length == 1) {\\n            return address(0);\\n        }\\n\\n        require(\\n            _in.length == 21,\\n            \\\"Invalid RLP address value.\\\"\\n        );\\n\\n        return address(readUint256(_in));\\n    }\\n\\n    /**\\n     * Reads an RLP address value into a address.\\n     * @param _in RLP address value.\\n     * @return Decoded address.\\n     */\\n    function readAddress(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            address\\n        )\\n    {\\n        return readAddress(\\n            toRLPItem(_in)\\n        );\\n    }\\n\\n    /**\\n     * Reads the raw bytes of an RLP item.\\n     * @param _in RLP item to read.\\n     * @return Raw RLP bytes.\\n     */\\n    function readRawBytes(\\n        RLPItem memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Decodes the length of an RLP item.\\n     * @param _in RLP item to decode.\\n     * @return Offset of the encoded data.\\n     * @return Length of the encoded data.\\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\\n     */\\n    function _decodeLength(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            uint256,\\n            uint256,\\n            RLPItemType\\n        )\\n    {\\n        require(\\n            _in.length > 0,\\n            \\\"RLP item cannot be null.\\\"\\n        );\\n\\n        uint256 ptr = _in.ptr;\\n        uint256 prefix;\\n        assembly {\\n            prefix := byte(0, mload(ptr))\\n        }\\n\\n        if (prefix <= 0x7f) {\\n            // Single byte.\\n\\n            return (0, 1, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xb7) {\\n            // Short string.\\n\\n            uint256 strLen = prefix - 0x80;\\n            \\n            require(\\n                _in.length > strLen,\\n                \\\"Invalid RLP short string.\\\"\\n            );\\n\\n            return (1, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xbf) {\\n            // Long string.\\n            uint256 lenOfStrLen = prefix - 0xb7;\\n\\n            require(\\n                _in.length > lenOfStrLen,\\n                \\\"Invalid RLP long string length.\\\"\\n            );\\n\\n            uint256 strLen;\\n            assembly {\\n                // Pick out the string length.\\n                strLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfStrLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfStrLen + strLen,\\n                \\\"Invalid RLP long string.\\\"\\n            );\\n\\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\\n        } else if (prefix <= 0xf7) {\\n            // Short list.\\n            uint256 listLen = prefix - 0xc0;\\n\\n            require(\\n                _in.length > listLen,\\n                \\\"Invalid RLP short list.\\\"\\n            );\\n\\n            return (1, listLen, RLPItemType.LIST_ITEM);\\n        } else {\\n            // Long list.\\n            uint256 lenOfListLen = prefix - 0xf7;\\n\\n            require(\\n                _in.length > lenOfListLen,\\n                \\\"Invalid RLP long list length.\\\"\\n            );\\n\\n            uint256 listLen;\\n            assembly {\\n                // Pick out the list length.\\n                listLen := div(\\n                    mload(add(ptr, 1)),\\n                    exp(256, sub(32, lenOfListLen))\\n                )\\n            }\\n\\n            require(\\n                _in.length > lenOfListLen + listLen,\\n                \\\"Invalid RLP long list.\\\"\\n            );\\n\\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\\n        }\\n    }\\n\\n    /**\\n     * Copies the bytes from a memory location.\\n     * @param _src Pointer to the location to read from.\\n     * @param _offset Offset to start reading from.\\n     * @param _length Number of bytes to read.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        uint256 _src,\\n        uint256 _offset,\\n        uint256 _length\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        bytes memory out = new bytes(_length);\\n        if (out.length == 0) {\\n            return out;\\n        }\\n\\n        uint256 src = _src + _offset;\\n        uint256 dest;\\n        assembly {\\n            dest := add(out, 32)\\n        }\\n\\n        // Copy over as many complete words as we can.\\n        for (uint256 i = 0; i < _length / 32; i++) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n\\n            src += 32;\\n            dest += 32;\\n        }\\n\\n        // Pick out the remaining bytes.\\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\\n        assembly {\\n            mstore(\\n                dest,\\n                or(\\n                    and(mload(src), not(mask)),\\n                    and(mload(dest), mask)\\n                )\\n            )\\n        }\\n\\n        return out;\\n    }\\n\\n    /**\\n     * Copies an RLP item into bytes.\\n     * @param _in RLP item to copy.\\n     * @return Copied bytes.\\n     */\\n    function _copy(\\n        RLPItem memory _in\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory\\n        )\\n    {\\n        return _copy(_in.ptr, 0, _in.length);\\n    }\\n}\\n\",\"keccak256\":\"0xf0c0dbbe5e77adb1b603d6d4af319d15cea8c6d66fd5dca8115d80917617bf77\",\"license\":\"MIT\"},\"contracts/libraries/Lib_RLPWriter.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_BytesUtils } from \\\"./Lib_BytesUtils.sol\\\";\\n\\n/**\\n * @title Lib_RLPWriter\\n * @author Bakaoh (with modifications)\\n */\\nlibrary Lib_RLPWriter {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * RLP encodes a byte string.\\n     * @param _in The byte string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeBytes(\\n        bytes memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\\n            encoded = _in;\\n        } else {\\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * RLP encodes a list of RLP encoded byte byte strings.\\n     * @param _in The list of RLP encoded byte strings.\\n     * @return _out The RLP encoded list of items in bytes.\\n     */\\n    function writeList(\\n        bytes[] memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory list = _flatten(_in);\\n        return abi.encodePacked(_writeLength(list.length, 192), list);\\n    }\\n\\n    /**\\n     * RLP encodes a string.\\n     * @param _in The string to encode.\\n     * @return _out The RLP encoded string in bytes.\\n     */\\n    function writeString(\\n        string memory _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(bytes(_in));\\n    }\\n\\n    /**\\n     * RLP encodes an address.\\n     * @param _in The address to encode.\\n     * @return _out The RLP encoded address in bytes.\\n     */\\n    function writeAddress(\\n        address _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bytes32 value.\\n     * @param _in The bytes32 to encode.\\n     * @return _out The RLP encoded bytes32 in bytes.\\n     */\\n    function writeBytes32(\\n        bytes32 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(abi.encodePacked(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a uint.\\n     * @param _in The uint256 to encode.\\n     * @return _out The RLP encoded uint256 in bytes.\\n     */\\n    function writeUint(\\n        uint256 _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        return writeBytes(_toBinary(_in));\\n    }\\n\\n    /**\\n     * RLP encodes a bool.\\n     * @param _in The bool to encode.\\n     * @return _out The RLP encoded bool in bytes.\\n     */\\n    function writeBool(\\n        bool _in\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes memory _out\\n        )\\n    {\\n        bytes memory encoded = new bytes(1);\\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\\n        return encoded;\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\\n     * @param _len The length of the string or the payload.\\n     * @param _offset 128 if item is string, 192 if item is list.\\n     * @return _encoded RLP encoded bytes.\\n     */\\n    function _writeLength(\\n        uint256 _len,\\n        uint256 _offset\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _encoded\\n        )\\n    {\\n        bytes memory encoded;\\n\\n        if (_len < 56) {\\n            encoded = new bytes(1);\\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\\n        } else {\\n            uint256 lenLen;\\n            uint256 i = 1;\\n            while (_len / i != 0) {\\n                lenLen++;\\n                i *= 256;\\n            }\\n\\n            encoded = new bytes(lenLen + 1);\\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\\n            for(i = 1; i <= lenLen; i++) {\\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\\n            }\\n        }\\n\\n        return encoded;\\n    }\\n\\n    /**\\n     * Encode integer in big endian binary form with no leading zeroes.\\n     * @notice TODO: This should be optimized with assembly to save gas costs.\\n     * @param _x The integer to encode.\\n     * @return _binary RLP encoded bytes.\\n     */\\n    function _toBinary(\\n        uint256 _x\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _binary\\n        )\\n    {\\n        bytes memory b = abi.encodePacked(_x);\\n\\n        uint256 i = 0;\\n        for (; i < 32; i++) {\\n            if (b[i] != 0) {\\n                break;\\n            }\\n        }\\n\\n        bytes memory res = new bytes(32 - i);\\n        for (uint256 j = 0; j < res.length; j++) {\\n            res[j] = b[i++];\\n        }\\n\\n        return res;\\n    }\\n\\n    /**\\n     * Copies a piece of memory to another location.\\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\\n     * @param _dest Destination location.\\n     * @param _src Source location.\\n     * @param _len Length of memory to copy.\\n     */\\n    function _memcpy(\\n        uint256 _dest,\\n        uint256 _src,\\n        uint256 _len\\n    )\\n        private\\n        pure\\n    {\\n        uint256 dest = _dest;\\n        uint256 src = _src;\\n        uint256 len = _len;\\n\\n        for(; len >= 32; len -= 32) {\\n            assembly {\\n                mstore(dest, mload(src))\\n            }\\n            dest += 32;\\n            src += 32;\\n        }\\n\\n        uint256 mask = 256 ** (32 - len) - 1;\\n        assembly {\\n            let srcpart := and(mload(src), not(mask))\\n            let destpart := and(mload(dest), mask)\\n            mstore(dest, or(destpart, srcpart))\\n        }\\n    }\\n\\n    /**\\n     * Flattens a list of byte strings into one byte string.\\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\\n     * @param _list List of byte strings to flatten.\\n     * @return _flattened The flattened byte string.\\n     */\\n    function _flatten(\\n        bytes[] memory _list\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _flattened\\n        )\\n    {\\n        if (_list.length == 0) {\\n            return new bytes(0);\\n        }\\n\\n        uint256 len;\\n        uint256 i = 0;\\n        for (; i < _list.length; i++) {\\n            len += _list[i].length;\\n        }\\n\\n        bytes memory flattened = new bytes(len);\\n        uint256 flattenedPtr;\\n        assembly { flattenedPtr := add(flattened, 0x20) }\\n\\n        for(i = 0; i < _list.length; i++) {\\n            bytes memory item = _list[i];\\n\\n            uint256 listPtr;\\n            assembly { listPtr := add(item, 0x20)}\\n\\n            _memcpy(flattenedPtr, listPtr, item.length);\\n            flattenedPtr += _list[i].length;\\n        }\\n\\n        return flattened;\\n    }\\n}\\n\",\"keccak256\":\"0x96575a2105c7f9b1f6c96b2aa274ea24c835601dded8fdaecbcf03f4c41ae08b\",\"license\":\"MIT\"},\"contracts/libraries/Lib_SecureMerkleTrie.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\npragma solidity >0.5.0 <0.8.0;\\npragma experimental ABIEncoderV2;\\n\\n/* Library Imports */\\nimport { Lib_MerkleTrie } from \\\"./Lib_MerkleTrie.sol\\\";\\n\\n/**\\n * @title Lib_SecureMerkleTrie\\n */\\nlibrary Lib_SecureMerkleTrie {\\n\\n    /**********************\\n     * Internal Functions *\\n     **********************/\\n\\n    /**\\n     * @notice Verifies a proof that a given key/value pair is present in the\\n     * Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _value Value of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\\n     * traditional Merkle trees, this proof is executed top-down and consists\\n     * of a list of RLP-encoded nodes that make a path down to the target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\\n     */\\n    function verifyInclusionProof(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _verified\\n        )\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Verifies a proof that a given key is *not* present in\\n     * the Merkle trie.\\n     * @param _key Key of the node to search for, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _verified `true` if the key is not present in the trie, `false` otherwise.\\n     */\\n    function verifyExclusionProof(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _verified\\n        )\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.verifyExclusionProof(key, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Updates a Merkle trie and returns a new root hash.\\n     * @param _key Key of the node to update, as a hex string.\\n     * @param _value Value of the node to update, as a hex string.\\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\\n     * target node. If the key exists, we can simply update the value.\\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\\n     * @param _root Known root of the Merkle trie. Used to verify that the\\n     * included proof is correctly constructed.\\n     * @return _updatedRoot Root hash of the newly constructed trie.\\n     */\\n    function update(\\n        bytes memory _key,\\n        bytes memory _value,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _updatedRoot\\n        )\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.update(key, _value, _proof, _root);\\n    }\\n\\n    /**\\n     * @notice Retrieves the value associated with a given key.\\n     * @param _key Key to search for, as hex bytes.\\n     * @param _proof Merkle trie inclusion proof for the key.\\n     * @param _root Known root of the Merkle trie.\\n     * @return _exists Whether or not the key exists.\\n     * @return _value Value of the key if it exists.\\n     */\\n    function get(\\n        bytes memory _key,\\n        bytes memory _proof,\\n        bytes32 _root\\n    )\\n        internal\\n        pure\\n        returns (\\n            bool _exists,\\n            bytes memory _value\\n        )\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.get(key, _proof, _root);\\n    }\\n\\n    /**\\n     * Computes the root hash for a trie with a single node.\\n     * @param _key Key for the single node.\\n     * @param _value Value for the single node.\\n     * @return _updatedRoot Hash of the trie.\\n     */\\n    function getSingleNodeRootHash(\\n        bytes memory _key,\\n        bytes memory _value\\n    )\\n        internal\\n        pure\\n        returns (\\n            bytes32 _updatedRoot\\n        )\\n    {\\n        bytes memory key = _getSecureKey(_key);\\n        return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);\\n    }\\n\\n\\n    /*********************\\n     * Private Functions *\\n     *********************/\\n\\n    /**\\n     * Computes the secure counterpart to a key.\\n     * @param _key Key to get a secure key from.\\n     * @return _secureKey Secure version of the key.\\n     */\\n    function _getSecureKey(\\n        bytes memory _key\\n    )\\n        private\\n        pure\\n        returns (\\n            bytes memory _secureKey\\n        )\\n    {\\n        return abi.encodePacked(keccak256(_key));\\n    }\\n}\\n\",\"keccak256\":\"0x866b8515eec71c17055d8fc4df9401d615997a8730eb08092c9e145fd25209b3\",\"license\":\"MIT\"}},\"version\":1}",
  "bytecode": "0x60806040523480156200001157600080fd5b50604051620047e8380380620047e8833981810160405260608110156200003757600080fd5b810190808051906020019092919080519060200190929190805160405193929190846401000000008211156200006c57600080fd5b838201915060208201858111156200008357600080fd5b8251866001820283011164010000000082111715620000a157600080fd5b8083526020830192505050908051906020019080838360005b83811015620000d7578082015181840152602081019050620000ba565b50505050905090810190601f168015620001055780820380516001836020036101000a031916815260200191505b5060405250505082420160058190555081600681905550814060078190555060006200013c826200017960201b620016c21760201c565b905062000169816003815181106200015057fe5b6020026020010151620001a360201b620016dc1760201c565b6008819055505050505062000997565b60606200019c62000190836200030160201b60201c565b6200033160201b60201c565b9050919050565b600060218260000151111562000221576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b600080600062000237856200053860201b60201c565b925092509250600060018111156200024b57fe5b8160018111156200025857fe5b14620002cc576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b60008386602001510190506000815190506020841015620002f457836020036101000a810490505b8095505050505050919050565b6200030b6200097d565b600060208301905060405180604001604052808451815260200182815250915050919050565b606060008062000347846200053860201b60201c565b92505091506001808111156200035957fe5b8160018111156200036657fe5b14620003da576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c50206c6973742076616c75652e00000000000000000081525060200191505060405180910390fd5b6000602067ffffffffffffffff81118015620003f557600080fd5b506040519080825280602002602001820160405280156200043357816020015b6200041f6200097d565b815260200190600190039081620004155790505b5090506000808490505b8660000151811015620005285760208210620004a5576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180620047be602a913960400191505060405180910390fd5b600080620004d96040518060400160405280858c60000151038152602001858c60200151018152506200053860201b60201c565b509150915060405180604001604052808383018152602001848b60200151018152508585815181106200050857fe5b60200260200101819052506001840193508082018301925050506200043d565b8183528295505050505050919050565b600080600080846000015111620005b7576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f524c50206974656d2063616e6e6f74206265206e756c6c2e000000000000000081525060200191505060405180910390fd5b6000846020015190506000815160001a9050607f8111620005e657600060016000945094509450505062000976565b60b78111620006855760006080820390508087600001511162000671576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f496e76616c696420524c502073686f727420737472696e672e0000000000000081525060200191505060405180910390fd5b600181600095509550955050505062000976565b60bf8111620007b557600060b7820390508087600001511162000710576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e0081525060200191505060405180910390fd5b6000816020036101000a60018501510490508082018860000151116200079e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f496e76616c696420524c50206c6f6e6720737472696e672e000000000000000081525060200191505060405180910390fd5b816001018160009650965096505050505062000976565b60f781116200085457600060c0820390508087600001511162000840576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c502073686f7274206c6973742e00000000000000000081525060200191505060405180910390fd5b600181600195509550955050505062000976565b600060f78203905080876000015111620008d6576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e00000081525060200191505060405180910390fd5b6000816020036101000a600185015104905080820188600001511162000964576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f496e76616c696420524c50206c6f6e67206c6973742e0000000000000000000081525060200191505060405180910390fd5b81600101816001965096509650505050505b9193909250565b604051806040016040528060008152602001600081525090565b613e1780620009a76000396000f3fe608060405234801561001057600080fd5b50600436106101215760003560e01c80635e47655f116100ad578063bb1757cf11610071578063bb1757cf14610643578063c884ef8314610734578063c91030ab1461078e578063dd62ed3e146107ac578063f25e71081461082457610121565b80635e47655f146103d957806370a08231146104aa5780638bcfa6651461050257806395d89b411461055c578063a9059cbb146105df57610121565b8063266d7bda116100f4578063266d7bda146102af57806327e235e3146102cd578063313ce567146103255780633c2ed25a146103435780635c6581651461036157610121565b806306fdde0314610126578063095ea7b3146101a957806318160ddd1461020d57806323b872dd1461022b575b600080fd5b61012e610842565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561016e578082015181840152602081019050610153565b50505050905090810190601f16801561019b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101f5600480360360408110156101bf57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061087b565b60405180821515815260200191505060405180910390f35b61021561096d565b6040518082815260200191505060405180910390f35b6102976004803603606081101561024157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610973565b60405180821515815260200191505060405180910390f35b6102b7610cd0565b6040518082815260200191505060405180910390f35b61030f600480360360208110156102e357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cd6565b6040518082815260200191505060405180910390f35b61032d610cee565b6040518082815260200191505060405180910390f35b61034b610cf3565b6040518082815260200191505060405180910390f35b6103c36004803603604081101561037757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cf9565b6040518082815260200191505060405180910390f35b610492600480360360208110156103ef57600080fd5b810190808035906020019064010000000081111561040c57600080fd5b82018360208201111561041e57600080fd5b8035906020019184600183028401116401000000008311171561044057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050610d1e565b60405180821515815260200191505060405180910390f35b6104ec600480360360208110156104c057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611091565b6040518082815260200191505060405180910390f35b6105446004803603602081101561051857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506110da565b60405180821515815260200191505060405180910390f35b6105646110fa565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105a4578082015181840152602081019050610589565b50505050905090810190601f1680156105d15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61062b600480360360408110156105f557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611133565b60405180821515815260200191505060405180910390f35b61071c6004803603604081101561065957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019064010000000081111561069657600080fd5b8201836020820111156106a857600080fd5b803590602001918460018302840111640100000000831117156106ca57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050611330565b60405180821515815260200191505060405180910390f35b6107766004803603602081101561074a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061160f565b60405180821515815260200191505060405180910390f35b61079661162f565b6040518082815260200191505060405180910390f35b61080e600480360360408110156107c257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611635565b6040518082815260200191505060405180910390f35b61082c6116bc565b6040518082815260200191505060405180910390f35b6040518060400160405280600881526020017f4d6178692045544800000000000000000000000000000000000000000000000081525081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60005481565b600060055442116109cf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602b815260200180613cef602b913960400191505060405180910390fd5b81600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610aa4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180613c226022913960400191505060405180910390fd5b81600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610b3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252604d815260200180613d5b604d913960600191505060405180910390fd5b81600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254019250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b60055481565b60016020528060005260406000206000915090505481565b601281565b60075481565b6002602052816000526040600020602052806000526040600020600091509150505481565b600080610d2c83600161182d565b90506000610d3982611a39565b905060011515600360008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16151514610de4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526039815260200180613c906039913960400191505060405180910390fd5b60001515600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16151514610e8d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602e815260200180613bf4602e913960400191505060405180910390fd5b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555080600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055506000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a33373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f96e0041f14ae401fab2384e3c29da20cb0263ef760c47847db1f13403cea654c836040518082815260200191505060405180910390a360019350505050919050565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60046020528060005260406000206000915054906101000a900460ff1681565b6040518060400160405280600481526020017f6d4554480000000000000000000000000000000000000000000000000000000081525081565b6000600554421161118f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602b815260200180613cef602b913960400191505060405180910390fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611227576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526041815260200180613d1a6041913960600191505060405180910390fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a36001905092915050565b6000801515600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515146113da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603a815260200180613da8603a913960400191505060405180910390fd5b60008061142285604051602001808273ffffffffffffffffffffffffffffffffffffffff1660601b815260140191505060405160208183030381529060405285600854611aaa565b915091506001151582151514611483576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180613c446022913960400191505060405180910390fd5b600061148e826116c2565b905060006114af826001815181106114a257fe5b6020026020010151611ad3565b90506001600360008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555080600160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a38673ffffffffffffffffffffffffffffffffffffffff167fd8138f8a3f377c5259ca548e70e4c2de94f129f5a11036a15b69513cba2b426a826040518082815260200191505060405180910390a2600194505050505092915050565b60036020528060005260406000206000915054906101000a900460ff1681565b60085481565b6000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b60065481565b60606116d56116d083611ae8565b611b16565b9050919050565b6000602182600001511115611759576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b600080600061176785611d00565b9250925092506000600181111561177a57fe5b81600181111561178657fe5b146117f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b6000838660200151019050600081519050602084101561182057836020036101000a810490505b8095505050505050919050565b61183561389a565b6000611840846116c2565b905060006118618260068151811061185457fe5b6020026020010151611ad3565b905060006023856002028360ff160303905060028160ff16106118b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118b090613ae1565b60405180910390fd5b6000806118d9856003815181106118cc57fe5b6020026020010151612136565b51149050604051806101800160405280611906866000815181106118f957fe5b6020026020010151611ad3565b81526020016119288660018151811061191b57fe5b6020026020010151611ad3565b815260200161194a8660028151811061193d57fe5b6020026020010151611ad3565b815260200161196c8660038151811061195f57fe5b60200260200101516121f1565b73ffffffffffffffffffffffffffffffffffffffff1681526020016119a48660048151811061199757fe5b6020026020010151611ad3565b81526020016119c6866005815181106119b957fe5b6020026020010151612136565b81526020018460ff1681526020016119f1866007815181106119e457fe5b60200260200101516116dc565b8152602001611a1386600881518110611a0657fe5b60200260200101516116dc565b81526020018781526020018360ff16815260200182151581525094505050505092915050565b60006001611a4683612294565b601b846101400151018460e0015185610100015160405160008152602001604052604051611a779493929190613a9c565b6020604051602081039080840390855afa158015611a99573d6000803e3d6000fd5b505050602060405103519050919050565b600060606000611ab9866122b8565b9050611ac68186866122e8565b9250925050935093915050565b6000611ade826116dc565b60001c9050919050565b611af061391f565b600060208301905060405180604001604052808451815260200182815250915050919050565b6060600080611b2484611d00565b9250509150600180811115611b3557fe5b816001811115611b4157fe5b14611bb4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c50206c6973742076616c75652e00000000000000000081525060200191505060405180910390fd5b6000602067ffffffffffffffff81118015611bce57600080fd5b50604051908082528060200260200182016040528015611c0857816020015b611bf561391f565b815260200190600190039081611bed5790505b5090506000808490505b8660000151811015611cf05760208210611c77576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180613c66602a913960400191505060405180910390fd5b600080611ca36040518060400160405280858c60000151038152602001858c6020015101815250611d00565b509150915060405180604001604052808383018152602001848b6020015101815250858581518110611cd157fe5b6020026020010181905250600184019350808201830192505050611c12565b8183528295505050505050919050565b600080600080846000015111611d7e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f524c50206974656d2063616e6e6f74206265206e756c6c2e000000000000000081525060200191505060405180910390fd5b6000846020015190506000815160001a9050607f8111611dab57600060016000945094509450505061212f565b60b78111611e4757600060808203905080876000015111611e34576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f496e76616c696420524c502073686f727420737472696e672e0000000000000081525060200191505060405180910390fd5b600181600095509550955050505061212f565b60bf8111611f7357600060b78203905080876000015111611ed0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e0081525060200191505060405180910390fd5b6000816020036101000a6001850151049050808201886000015111611f5d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f496e76616c696420524c50206c6f6e6720737472696e672e000000000000000081525060200191505060405180910390fd5b816001018160009650965096505050505061212f565b60f7811161200f57600060c08203905080876000015111611ffc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c502073686f7274206c6973742e00000000000000000081525060200191505060405180910390fd5b600181600195509550955050505061212f565b600060f78203905080876000015111612090576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e00000081525060200191505060405180910390fd5b6000816020036101000a600185015104905080820188600001511161211d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f496e76616c696420524c50206c6f6e67206c6973742e0000000000000000000081525060200191505060405180910390fd5b81600101816001965096509650505050505b9193909250565b6060600080600061214685611d00565b9250925092506000600181111561215957fe5b81600181111561216557fe5b146121d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f496e76616c696420524c502062797465732076616c75652e000000000000000081525060200191505060405180910390fd5b6121e7856020015184846123e4565b9350505050919050565b6000600182600001511415612209576000905061228f565b6015826000015114612283576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020616464726573732076616c75652e00000000000081525060200191505060405180910390fd5b61228c82611ad3565b90505b919050565b60006122aa6000836124be90919063ffffffff16565b805190602001209050919050565b606081805190602001206040516020016122d29190613a42565b6040516020818303038152906040529050919050565b6000606060006122f785612747565b90506000806000612309848a89612826565b925092509250600080835114905080806123205750815b612392576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f50726f76696465642070726f6f6620697320696e76616c69642e00000000000081525060200191505060405180910390fd5b6000816123ae57604051806020016040528060008152506123ce565b6123cd8660018703815181106123c057fe5b6020026020010151612d25565b5b9050818197509750505050505050935093915050565b606060008267ffffffffffffffff811180156123ff57600080fd5b506040519080825280601f01601f1916602001820160405280156124325781602001600182028036833780820191505090505b50905060008151141561244857809150506124b7565b60008486019050600060208301905060005b6020868161246457fe5b048110156124895782518252602083019250602082019150808060010191505061245a565b50600060016020878161249857fe5b066020036101000a039050808251168119845116178252839450505050505b9392505050565b60606000600967ffffffffffffffff811180156124da57600080fd5b5060405190808252806020026020018201604052801561250e57816020015b60608152602001906001900390816124f95790505b50905061251e8460000151612d56565b8160008151811061252b57fe5b60200260200101819052506125438460200151612d56565b8160018151811061255057fe5b60200260200101819052506125688460400151612d56565b8160028151811061257557fe5b6020026020010181905250836101600151156125c0576125a360405180602001604052806000815250612d70565b816003815181106125b057fe5b60200260200101819052506125e6565b6125cd8460600151612de7565b816003815181106125da57fe5b60200260200101819052505b6125f38460800151612d56565b8160048151811061260057fe5b60200260200101819052506126188460a00151612d70565b8160058151811061262557fe5b602002602001018190525082156126ae576126468460c0015160ff16612d56565b8160068151811061265357fe5b602002602001018190525061266b8460e00151612e18565b8160078151811061267857fe5b6020026020010181905250612691846101000151612e18565b8160088151811061269e57fe5b6020026020010181905250612735565b6126bc846101200151612d56565b816006815181106126c957fe5b60200260200101819052506126ec60405180602001604052806000815250612d70565b816007815181106126f957fe5b602002602001018190525061271c60405180602001604052806000815250612d70565b8160088151811061272957fe5b60200260200101819052505b61273e81612e49565b91505092915050565b60606000612754836116c2565b90506000815167ffffffffffffffff8111801561277057600080fd5b506040519080825280602002602001820160405280156127aa57816020015b612797613939565b81526020019060019003908161278f5790505b50905060005b825181101561281b5760006127d78483815181106127ca57fe5b6020026020010151612136565b905060405180604001604052808281526020016127f3836116c2565b81525083838151811061280257fe5b60200260200101819052505080806001019150506127b0565b508092505050919050565b6000606060008060009050600061283c87612e8d565b9050600086905060008061284e613939565b60005b8c51811015612cd5578c818151811061286657fe5b6020026020010151915082840193506001870196506000841415612909578482600001518051906020012014612904576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f496e76616c696420726f6f74206861736800000000000000000000000000000081525060200191505060405180910390fd5b612a1e565b60208260000151511061299b578482600001518051906020012014612996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601b8152602001807f496e76616c6964206c6172676520696e7465726e616c2068617368000000000081525060200191505060405180910390fd5b612a1d565b846129a98360000151612feb565b14612a1c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420696e7465726e616c206e6f6465206861736800000000000081525060200191505060405180910390fd5b5b5b60016010018260200151511415612a90578551841415612a3d57612cd5565b6000868581518110612a4b57fe5b602001015160f81c60f81b60f81c9050600083602001518260ff1681518110612a7057fe5b60200260200101519050612a8381613037565b9650600194505050612cc8565b60028260200151511415612c5a576000612aa983613075565b9050600081600081518110612aba57fe5b602001015160f81c60f81b60f81c9050600060028260ff1681612ad957fe5b0660020390506000612aee848360ff166130a7565b90506000612afc8b8a6130a7565b90506000612b0a83836130e3565b9050600260ff168560ff161480612b275750600360ff168560ff16145b15612b7b57808351148015612b3c5750808251145b15612b4757808a0199505b608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169a50505050505050612cd5565b600060ff168560ff161480612b965750600160ff168560ff16145b15612c09576000811415612bd857608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169a50505050505050612cd5565b612bf98860200151600181518110612bec57fe5b6020026020010151613037565b9a50809850505050505050612cc8565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526026815260200180613cc96026913960400191505060405180910390fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f526563656976656420616e20756e706172736561626c65206e6f64652e00000081525060200191505060405180910390fd5b8080600101915050612851565b506000608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168514905086612d0e87866130a7565b829950995099505050505050505093509350939050565b6060612d4f826020015160018460200151510381518110612d4257fe5b6020026020010151612136565b9050919050565b6060612d69612d6483613192565b612d70565b9050919050565b60608060018351148015612da15750608083600081518110612d8e57fe5b602001015160f81c60f81b60f81c60ff16105b15612dae57829050612dde565b612dba835160806132e8565b83604051602001612dcc929190613a5d565b60405160208183030381529060405290505b80915050919050565b6060612e1182604051602001612dfd9190613a27565b604051602081830303815290604052612d70565b9050919050565b6060612e4282604051602001612e2e9190613a42565b604051602081830303815290604052612d70565b9050919050565b60606000612e56836134ca565b9050612e64815160c06132e8565b81604051602001612e76929190613a5d565b604051602081830303815290604052915050919050565b60606000600283510267ffffffffffffffff81118015612eac57600080fd5b506040519080825280601f01601f191660200182016040528015612edf5781602001600182028036833780820191505090505b50905060005b8351811015612fe1576004848281518110612efc57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c826002830281518110612f3a57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506010848281518110612f7757fe5b602001015160f81c60f81b60f81c60ff1681612f8f57fe5b0660f81b826001600284020181518110612fa557fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050612ee5565b5080915050919050565b60006020825110156130095760006020830151905080915050613032565b81806020019051602081101561301e57600080fd5b810190808051906020019092919050505090505b919050565b600060606020836000015110156130585761305183613626565b9050613064565b61306183612136565b90505b61306d81612feb565b915050919050565b60606130a061309b836020015160008151811061308e57fe5b6020026020010151612136565b612e8d565b9050919050565b606060008284510314156130cc576040518060200160405280600081525090506130dd565b6130da838384865103613638565b90505b92915050565b600080600090505b8084511180156130fb5750808351115b8015613176575082818151811061310e57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191684828151811061314757fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156131885780806001019150506130eb565b8091505092915050565b60606000826040516020016131a79190613a81565b604051602081830303815290604052905060005b602081101561321957600060f81b8282815181106131d557fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161461320c57613219565b80806001019150506131bb565b60008160200367ffffffffffffffff8111801561323557600080fd5b506040519080825280601f01601f1916602001820160405280156132685781602001600182028036833780820191505090505b50905060005b81518110156132dc5783838060010194508151811061328957fe5b602001015160f81c60f81b8282815181106132a057fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808060010191505061326e565b50809350505050919050565b606080603884101561338957600167ffffffffffffffff8111801561330c57600080fd5b506040519080825280601f01601f19166020018201604052801561333f5781602001600182028036833780820191505090505b50905082840160f81b8160008151811061335557fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506134c0565b600080600190505b600081878161339c57fe5b04146133b657818060010192505061010081029050613391565b6001820167ffffffffffffffff811180156133d057600080fd5b506040519080825280601f01601f1916602001820160405280156134035781602001600182028036833780820191505090505b50925060378583010160f81b8360008151811061341c57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116134bd576101008183036101000a878161346957fe5b048161347157fe5b0660f81b83828151811061348157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050613450565b50505b8091505092915050565b606060008251141561352957600067ffffffffffffffff811180156134ee57600080fd5b506040519080825280601f01601f1916602001820160405280156135215781602001600182028036833780820191505090505b509050613621565b600080600090505b83518110156135605783818151811061354657fe5b602002602001015151820191508080600101915050613531565b60008267ffffffffffffffff8111801561357957600080fd5b506040519080825280601f01601f1916602001820160405280156135ac5781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156136195760008684815181106135d357fe5b6020026020010151905060006020820190506135f183828451613822565b8785815181106135fd57fe5b60200260200101515183019250505082806001019350506135bc565b819450505050505b919050565b60606136318261387d565b9050919050565b606081601f830110156136b3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f736c6963655f6f766572666c6f7700000000000000000000000000000000000081525060200191505060405180910390fd5b82828401101561372b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f736c6963655f6f766572666c6f7700000000000000000000000000000000000081525060200191505060405180910390fd5b818301845110156137a4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f736c6963655f6f75744f66426f756e647300000000000000000000000000000081525060200191505060405180910390fd5b60608215600081146137c55760405191506000825260208201604052613816565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561380357805183526020830192506020810190506137e6565b50868552601f19601f8301166040525050505b50809150509392505050565b6000839050600083905060008390505b602081106138555781518352602083019250602082019150602081039050613832565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b60606138938260200151600084600001516123e4565b9050919050565b604051806101800160405280600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160608152602001600060ff168152602001600080191681526020016000801916815260200160008152602001600060ff1681526020016000151581525090565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001606081525090565b61396461395f82613b28565b613bae565b82525050565b61397381613b3a565b82525050565b61398a61398582613b3a565b613bc0565b82525050565b600061399b82613b01565b6139a58185613b0c565b93506139b5818560208601613b7b565b80840191505092915050565b60006139ce601e83613b17565b91507f4c69625f45495031353554783a20696e76616c696420636861696e20696400006000830152602082019050919050565b613a12613a0d82613b64565b613bdc565b82525050565b613a2181613b6e565b82525050565b6000613a338284613953565b60148201915081905092915050565b6000613a4e8284613979565b60208201915081905092915050565b6000613a698285613990565b9150613a758284613990565b91508190509392505050565b6000613a8d8284613a01565b60208201915081905092915050565b6000608082019050613ab1600083018761396a565b613abe6020830186613a18565b613acb604083018561396a565b613ad8606083018461396a565b95945050505050565b60006020820190508181036000830152613afa816139c1565b9050919050565b600081519050919050565b600081905092915050565b600082825260208201905092915050565b6000613b3382613b44565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b83811015613b99578082015181840152602081019050613b7e565b83811115613ba8576000848401525b50505050565b6000613bb982613bca565b9050919050565b6000819050919050565b6000613bd582613be6565b9050919050565b6000819050919050565b60008160601b905091905056fe4554484d617869546f6b656e3a20616464726573732068617320616c7265616479206265656e20736c61736865644554484d617869546f6b656e3a206e6f7420656e6f75676820616c6c6f77616e63654554484d617869546f6b656e3a2062616420657468206d65726b6c652070726f6f6650726f766964656420524c50206c6973742065786365656473206d6178206c697374206c656e6774682e4554484d617869546f6b656e3a2063616e277420736c6173682062656361757365207468652075736572206861736e277420636c61696d656452656365697665642061206e6f6465207769746820616e20756e6b6e6f776e207072656669784554484d617869546f6b656e3a206c6f636b7570206861736e277420656e646564207965742c206e6572644554484d617869546f6b656e3a20796f7520646f6e2774206861766520656e6f7567682062616c616e636520746f206d616b652074686973207472616e736665724554484d617869546f6b656e3a206f776e6572206163636f756e7420646f65736e2774206861766520656e6f7567682062616c616e636520746f206d616b652074686973207472616e736665724554484d617869546f6b656e3a2062616c616e636520666f7220616464726573732068617320616c7265616479206265656e20636c61696d6564a264697066735822122026308732be8e24d51e0bcd20ef97982cdbd2b4d185eb8aeb6cb02aa1c669661464736f6c6343000706003350726f766964656420524c50206c6973742065786365656473206d6178206c697374206c656e6774682e",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106101215760003560e01c80635e47655f116100ad578063bb1757cf11610071578063bb1757cf14610643578063c884ef8314610734578063c91030ab1461078e578063dd62ed3e146107ac578063f25e71081461082457610121565b80635e47655f146103d957806370a08231146104aa5780638bcfa6651461050257806395d89b411461055c578063a9059cbb146105df57610121565b8063266d7bda116100f4578063266d7bda146102af57806327e235e3146102cd578063313ce567146103255780633c2ed25a146103435780635c6581651461036157610121565b806306fdde0314610126578063095ea7b3146101a957806318160ddd1461020d57806323b872dd1461022b575b600080fd5b61012e610842565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561016e578082015181840152602081019050610153565b50505050905090810190601f16801561019b5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101f5600480360360408110156101bf57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061087b565b60405180821515815260200191505060405180910390f35b61021561096d565b6040518082815260200191505060405180910390f35b6102976004803603606081101561024157600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050610973565b60405180821515815260200191505060405180910390f35b6102b7610cd0565b6040518082815260200191505060405180910390f35b61030f600480360360208110156102e357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cd6565b6040518082815260200191505060405180910390f35b61032d610cee565b6040518082815260200191505060405180910390f35b61034b610cf3565b6040518082815260200191505060405180910390f35b6103c36004803603604081101561037757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610cf9565b6040518082815260200191505060405180910390f35b610492600480360360208110156103ef57600080fd5b810190808035906020019064010000000081111561040c57600080fd5b82018360208201111561041e57600080fd5b8035906020019184600183028401116401000000008311171561044057600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050610d1e565b60405180821515815260200191505060405180910390f35b6104ec600480360360208110156104c057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611091565b6040518082815260200191505060405180910390f35b6105446004803603602081101561051857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506110da565b60405180821515815260200191505060405180910390f35b6105646110fa565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156105a4578082015181840152602081019050610589565b50505050905090810190601f1680156105d15780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b61062b600480360360408110156105f557600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611133565b60405180821515815260200191505060405180910390f35b61071c6004803603604081101561065957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019064010000000081111561069657600080fd5b8201836020820111156106a857600080fd5b803590602001918460018302840111640100000000831117156106ca57600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050611330565b60405180821515815260200191505060405180910390f35b6107766004803603602081101561074a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061160f565b60405180821515815260200191505060405180910390f35b61079661162f565b6040518082815260200191505060405180910390f35b61080e600480360360408110156107c257600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611635565b6040518082815260200191505060405180910390f35b61082c6116bc565b6040518082815260200191505060405180910390f35b6040518060400160405280600881526020017f4d6178692045544800000000000000000000000000000000000000000000000081525081565b600081600260003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60005481565b600060055442116109cf576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602b815260200180613cef602b913960400191505060405180910390fd5b81600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610aa4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180613c226022913960400191505060405180910390fd5b81600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610b3c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252604d815260200180613d5b604d913960600191505060405180910390fd5b81600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254019250508190555081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a3600190509392505050565b60055481565b60016020528060005260406000206000915090505481565b601281565b60075481565b6002602052816000526040600020602052806000526040600020600091509150505481565b600080610d2c83600161182d565b90506000610d3982611a39565b905060011515600360008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16151514610de4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526039815260200180613c906039913960400191505060405180910390fd5b60001515600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16151514610e8d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602e815260200180613bf4602e913960400191505060405180910390fd5b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506001600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555080600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055506000600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055503373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a33373ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167f96e0041f14ae401fab2384e3c29da20cb0263ef760c47847db1f13403cea654c836040518082815260200191505060405180910390a360019350505050919050565b6000600160008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60046020528060005260406000206000915054906101000a900460ff1681565b6040518060400160405280600481526020017f6d4554480000000000000000000000000000000000000000000000000000000081525081565b6000600554421161118f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602b815260200180613cef602b913960400191505060405180910390fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015611227576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526041815260200180613d1a6041913960600191505060405180910390fd5b81600160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a36001905092915050565b6000801515600360008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515146113da576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252603a815260200180613da8603a913960400191505060405180910390fd5b60008061142285604051602001808273ffffffffffffffffffffffffffffffffffffffff1660601b815260140191505060405160208183030381529060405285600854611aaa565b915091506001151582151514611483576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526022815260200180613c446022913960400191505060405180910390fd5b600061148e826116c2565b905060006114af826001815181106114a257fe5b6020026020010151611ad3565b90506001600360008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff02191690831515021790555080600160008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508673ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a38673ffffffffffffffffffffffffffffffffffffffff167fd8138f8a3f377c5259ca548e70e4c2de94f129f5a11036a15b69513cba2b426a826040518082815260200191505060405180910390a2600194505050505092915050565b60036020528060005260406000206000915054906101000a900460ff1681565b60085481565b6000600260008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b60065481565b60606116d56116d083611ae8565b611b16565b9050919050565b6000602182600001511115611759576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b600080600061176785611d00565b9250925092506000600181111561177a57fe5b81600181111561178657fe5b146117f9576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020627974657333322076616c75652e00000000000081525060200191505060405180910390fd5b6000838660200151019050600081519050602084101561182057836020036101000a810490505b8095505050505050919050565b61183561389a565b6000611840846116c2565b905060006118618260068151811061185457fe5b6020026020010151611ad3565b905060006023856002028360ff160303905060028160ff16106118b9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118b090613ae1565b60405180910390fd5b6000806118d9856003815181106118cc57fe5b6020026020010151612136565b51149050604051806101800160405280611906866000815181106118f957fe5b6020026020010151611ad3565b81526020016119288660018151811061191b57fe5b6020026020010151611ad3565b815260200161194a8660028151811061193d57fe5b6020026020010151611ad3565b815260200161196c8660038151811061195f57fe5b60200260200101516121f1565b73ffffffffffffffffffffffffffffffffffffffff1681526020016119a48660048151811061199757fe5b6020026020010151611ad3565b81526020016119c6866005815181106119b957fe5b6020026020010151612136565b81526020018460ff1681526020016119f1866007815181106119e457fe5b60200260200101516116dc565b8152602001611a1386600881518110611a0657fe5b60200260200101516116dc565b81526020018781526020018360ff16815260200182151581525094505050505092915050565b60006001611a4683612294565b601b846101400151018460e0015185610100015160405160008152602001604052604051611a779493929190613a9c565b6020604051602081039080840390855afa158015611a99573d6000803e3d6000fd5b505050602060405103519050919050565b600060606000611ab9866122b8565b9050611ac68186866122e8565b9250925050935093915050565b6000611ade826116dc565b60001c9050919050565b611af061391f565b600060208301905060405180604001604052808451815260200182815250915050919050565b6060600080611b2484611d00565b9250509150600180811115611b3557fe5b816001811115611b4157fe5b14611bb4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c50206c6973742076616c75652e00000000000000000081525060200191505060405180910390fd5b6000602067ffffffffffffffff81118015611bce57600080fd5b50604051908082528060200260200182016040528015611c0857816020015b611bf561391f565b815260200190600190039081611bed5790505b5090506000808490505b8660000151811015611cf05760208210611c77576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602a815260200180613c66602a913960400191505060405180910390fd5b600080611ca36040518060400160405280858c60000151038152602001858c6020015101815250611d00565b509150915060405180604001604052808383018152602001848b6020015101815250858581518110611cd157fe5b6020026020010181905250600184019350808201830192505050611c12565b8183528295505050505050919050565b600080600080846000015111611d7e576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f524c50206974656d2063616e6e6f74206265206e756c6c2e000000000000000081525060200191505060405180910390fd5b6000846020015190506000815160001a9050607f8111611dab57600060016000945094509450505061212f565b60b78111611e4757600060808203905080876000015111611e34576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260198152602001807f496e76616c696420524c502073686f727420737472696e672e0000000000000081525060200191505060405180910390fd5b600181600095509550955050505061212f565b60bf8111611f7357600060b78203905080876000015111611ed0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f496e76616c696420524c50206c6f6e6720737472696e67206c656e6774682e0081525060200191505060405180910390fd5b6000816020036101000a6001850151049050808201886000015111611f5d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f496e76616c696420524c50206c6f6e6720737472696e672e000000000000000081525060200191505060405180910390fd5b816001018160009650965096505050505061212f565b60f7811161200f57600060c08203905080876000015111611ffc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260178152602001807f496e76616c696420524c502073686f7274206c6973742e00000000000000000081525060200191505060405180910390fd5b600181600195509550955050505061212f565b600060f78203905080876000015111612090576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f496e76616c696420524c50206c6f6e67206c697374206c656e6774682e00000081525060200191505060405180910390fd5b6000816020036101000a600185015104905080820188600001511161211d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260168152602001807f496e76616c696420524c50206c6f6e67206c6973742e0000000000000000000081525060200191505060405180910390fd5b81600101816001965096509650505050505b9193909250565b6060600080600061214685611d00565b9250925092506000600181111561215957fe5b81600181111561216557fe5b146121d8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f496e76616c696420524c502062797465732076616c75652e000000000000000081525060200191505060405180910390fd5b6121e7856020015184846123e4565b9350505050919050565b6000600182600001511415612209576000905061228f565b6015826000015114612283576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420524c5020616464726573732076616c75652e00000000000081525060200191505060405180910390fd5b61228c82611ad3565b90505b919050565b60006122aa6000836124be90919063ffffffff16565b805190602001209050919050565b606081805190602001206040516020016122d29190613a42565b6040516020818303038152906040529050919050565b6000606060006122f785612747565b90506000806000612309848a89612826565b925092509250600080835114905080806123205750815b612392576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f50726f76696465642070726f6f6620697320696e76616c69642e00000000000081525060200191505060405180910390fd5b6000816123ae57604051806020016040528060008152506123ce565b6123cd8660018703815181106123c057fe5b6020026020010151612d25565b5b9050818197509750505050505050935093915050565b606060008267ffffffffffffffff811180156123ff57600080fd5b506040519080825280601f01601f1916602001820160405280156124325781602001600182028036833780820191505090505b50905060008151141561244857809150506124b7565b60008486019050600060208301905060005b6020868161246457fe5b048110156124895782518252602083019250602082019150808060010191505061245a565b50600060016020878161249857fe5b066020036101000a039050808251168119845116178252839450505050505b9392505050565b60606000600967ffffffffffffffff811180156124da57600080fd5b5060405190808252806020026020018201604052801561250e57816020015b60608152602001906001900390816124f95790505b50905061251e8460000151612d56565b8160008151811061252b57fe5b60200260200101819052506125438460200151612d56565b8160018151811061255057fe5b60200260200101819052506125688460400151612d56565b8160028151811061257557fe5b6020026020010181905250836101600151156125c0576125a360405180602001604052806000815250612d70565b816003815181106125b057fe5b60200260200101819052506125e6565b6125cd8460600151612de7565b816003815181106125da57fe5b60200260200101819052505b6125f38460800151612d56565b8160048151811061260057fe5b60200260200101819052506126188460a00151612d70565b8160058151811061262557fe5b602002602001018190525082156126ae576126468460c0015160ff16612d56565b8160068151811061265357fe5b602002602001018190525061266b8460e00151612e18565b8160078151811061267857fe5b6020026020010181905250612691846101000151612e18565b8160088151811061269e57fe5b6020026020010181905250612735565b6126bc846101200151612d56565b816006815181106126c957fe5b60200260200101819052506126ec60405180602001604052806000815250612d70565b816007815181106126f957fe5b602002602001018190525061271c60405180602001604052806000815250612d70565b8160088151811061272957fe5b60200260200101819052505b61273e81612e49565b91505092915050565b60606000612754836116c2565b90506000815167ffffffffffffffff8111801561277057600080fd5b506040519080825280602002602001820160405280156127aa57816020015b612797613939565b81526020019060019003908161278f5790505b50905060005b825181101561281b5760006127d78483815181106127ca57fe5b6020026020010151612136565b905060405180604001604052808281526020016127f3836116c2565b81525083838151811061280257fe5b60200260200101819052505080806001019150506127b0565b508092505050919050565b6000606060008060009050600061283c87612e8d565b9050600086905060008061284e613939565b60005b8c51811015612cd5578c818151811061286657fe5b6020026020010151915082840193506001870196506000841415612909578482600001518051906020012014612904576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f496e76616c696420726f6f74206861736800000000000000000000000000000081525060200191505060405180910390fd5b612a1e565b60208260000151511061299b578482600001518051906020012014612996576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601b8152602001807f496e76616c6964206c6172676520696e7465726e616c2068617368000000000081525060200191505060405180910390fd5b612a1d565b846129a98360000151612feb565b14612a1c576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f496e76616c696420696e7465726e616c206e6f6465206861736800000000000081525060200191505060405180910390fd5b5b5b60016010018260200151511415612a90578551841415612a3d57612cd5565b6000868581518110612a4b57fe5b602001015160f81c60f81b60f81c9050600083602001518260ff1681518110612a7057fe5b60200260200101519050612a8381613037565b9650600194505050612cc8565b60028260200151511415612c5a576000612aa983613075565b9050600081600081518110612aba57fe5b602001015160f81c60f81b60f81c9050600060028260ff1681612ad957fe5b0660020390506000612aee848360ff166130a7565b90506000612afc8b8a6130a7565b90506000612b0a83836130e3565b9050600260ff168560ff161480612b275750600360ff168560ff16145b15612b7b57808351148015612b3c5750808251145b15612b4757808a0199505b608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169a50505050505050612cd5565b600060ff168560ff161480612b965750600160ff168560ff16145b15612c09576000811415612bd857608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19169a50505050505050612cd5565b612bf98860200151600181518110612bec57fe5b6020026020010151613037565b9a50809850505050505050612cc8565b6040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401808060200182810382526026815260200180613cc96026913960400191505060405180910390fd5b6040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601d8152602001807f526563656976656420616e20756e706172736561626c65206e6f64652e00000081525060200191505060405180910390fd5b8080600101915050612851565b506000608060f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19168514905086612d0e87866130a7565b829950995099505050505050505093509350939050565b6060612d4f826020015160018460200151510381518110612d4257fe5b6020026020010151612136565b9050919050565b6060612d69612d6483613192565b612d70565b9050919050565b60608060018351148015612da15750608083600081518110612d8e57fe5b602001015160f81c60f81b60f81c60ff16105b15612dae57829050612dde565b612dba835160806132e8565b83604051602001612dcc929190613a5d565b60405160208183030381529060405290505b80915050919050565b6060612e1182604051602001612dfd9190613a27565b604051602081830303815290604052612d70565b9050919050565b6060612e4282604051602001612e2e9190613a42565b604051602081830303815290604052612d70565b9050919050565b60606000612e56836134ca565b9050612e64815160c06132e8565b81604051602001612e76929190613a5d565b604051602081830303815290604052915050919050565b60606000600283510267ffffffffffffffff81118015612eac57600080fd5b506040519080825280601f01601f191660200182016040528015612edf5781602001600182028036833780820191505090505b50905060005b8351811015612fe1576004848281518110612efc57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c826002830281518110612f3a57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506010848281518110612f7757fe5b602001015160f81c60f81b60f81c60ff1681612f8f57fe5b0660f81b826001600284020181518110612fa557fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050612ee5565b5080915050919050565b60006020825110156130095760006020830151905080915050613032565b81806020019051602081101561301e57600080fd5b810190808051906020019092919050505090505b919050565b600060606020836000015110156130585761305183613626565b9050613064565b61306183612136565b90505b61306d81612feb565b915050919050565b60606130a061309b836020015160008151811061308e57fe5b6020026020010151612136565b612e8d565b9050919050565b606060008284510314156130cc576040518060200160405280600081525090506130dd565b6130da838384865103613638565b90505b92915050565b600080600090505b8084511180156130fb5750808351115b8015613176575082818151811061310e57fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff191684828151811061314757fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916145b156131885780806001019150506130eb565b8091505092915050565b60606000826040516020016131a79190613a81565b604051602081830303815290604052905060005b602081101561321957600060f81b8282815181106131d557fe5b602001015160f81c60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff19161461320c57613219565b80806001019150506131bb565b60008160200367ffffffffffffffff8111801561323557600080fd5b506040519080825280601f01601f1916602001820160405280156132685781602001600182028036833780820191505090505b50905060005b81518110156132dc5783838060010194508151811061328957fe5b602001015160f81c60f81b8282815181106132a057fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350808060010191505061326e565b50809350505050919050565b606080603884101561338957600167ffffffffffffffff8111801561330c57600080fd5b506040519080825280601f01601f19166020018201604052801561333f5781602001600182028036833780820191505090505b50905082840160f81b8160008151811061335557fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053506134c0565b600080600190505b600081878161339c57fe5b04146133b657818060010192505061010081029050613391565b6001820167ffffffffffffffff811180156133d057600080fd5b506040519080825280601f01601f1916602001820160405280156134035781602001600182028036833780820191505090505b50925060378583010160f81b8360008151811061341c57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a905350600190505b8181116134bd576101008183036101000a878161346957fe5b048161347157fe5b0660f81b83828151811061348157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050613450565b50505b8091505092915050565b606060008251141561352957600067ffffffffffffffff811180156134ee57600080fd5b506040519080825280601f01601f1916602001820160405280156135215781602001600182028036833780820191505090505b509050613621565b600080600090505b83518110156135605783818151811061354657fe5b602002602001015151820191508080600101915050613531565b60008267ffffffffffffffff8111801561357957600080fd5b506040519080825280601f01601f1916602001820160405280156135ac5781602001600182028036833780820191505090505b5090506000602082019050600092505b85518310156136195760008684815181106135d357fe5b6020026020010151905060006020820190506135f183828451613822565b8785815181106135fd57fe5b60200260200101515183019250505082806001019350506135bc565b819450505050505b919050565b60606136318261387d565b9050919050565b606081601f830110156136b3576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f736c6963655f6f766572666c6f7700000000000000000000000000000000000081525060200191505060405180910390fd5b82828401101561372b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600e8152602001807f736c6963655f6f766572666c6f7700000000000000000000000000000000000081525060200191505060405180910390fd5b818301845110156137a4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f736c6963655f6f75744f66426f756e647300000000000000000000000000000081525060200191505060405180910390fd5b60608215600081146137c55760405191506000825260208201604052613816565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561380357805183526020830192506020810190506137e6565b50868552601f19601f8301166040525050505b50809150509392505050565b6000839050600083905060008390505b602081106138555781518352602083019250602082019150602081039050613832565b60006001826020036101000a0390508019835116818551168181178652505050505050505050565b60606138938260200151600084600001516123e4565b9050919050565b604051806101800160405280600081526020016000815260200160008152602001600073ffffffffffffffffffffffffffffffffffffffff1681526020016000815260200160608152602001600060ff168152602001600080191681526020016000801916815260200160008152602001600060ff1681526020016000151581525090565b604051806040016040528060008152602001600081525090565b604051806040016040528060608152602001606081525090565b61396461395f82613b28565b613bae565b82525050565b61397381613b3a565b82525050565b61398a61398582613b3a565b613bc0565b82525050565b600061399b82613b01565b6139a58185613b0c565b93506139b5818560208601613b7b565b80840191505092915050565b60006139ce601e83613b17565b91507f4c69625f45495031353554783a20696e76616c696420636861696e20696400006000830152602082019050919050565b613a12613a0d82613b64565b613bdc565b82525050565b613a2181613b6e565b82525050565b6000613a338284613953565b60148201915081905092915050565b6000613a4e8284613979565b60208201915081905092915050565b6000613a698285613990565b9150613a758284613990565b91508190509392505050565b6000613a8d8284613a01565b60208201915081905092915050565b6000608082019050613ab1600083018761396a565b613abe6020830186613a18565b613acb604083018561396a565b613ad8606083018461396a565b95945050505050565b60006020820190508181036000830152613afa816139c1565b9050919050565b600081519050919050565b600081905092915050565b600082825260208201905092915050565b6000613b3382613b44565b9050919050565b6000819050919050565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b6000819050919050565b600060ff82169050919050565b60005b83811015613b99578082015181840152602081019050613b7e565b83811115613ba8576000848401525b50505050565b6000613bb982613bca565b9050919050565b6000819050919050565b6000613bd582613be6565b9050919050565b6000819050919050565b60008160601b905091905056fe4554484d617869546f6b656e3a20616464726573732068617320616c7265616479206265656e20736c61736865644554484d617869546f6b656e3a206e6f7420656e6f75676820616c6c6f77616e63654554484d617869546f6b656e3a2062616420657468206d65726b6c652070726f6f6650726f766964656420524c50206c6973742065786365656473206d6178206c697374206c656e6774682e4554484d617869546f6b656e3a2063616e277420736c6173682062656361757365207468652075736572206861736e277420636c61696d656452656365697665642061206e6f6465207769746820616e20756e6b6e6f776e207072656669784554484d617869546f6b656e3a206c6f636b7570206861736e277420656e646564207965742c206e6572644554484d617869546f6b656e3a20796f7520646f6e2774206861766520656e6f7567682062616c616e636520746f206d616b652074686973207472616e736665724554484d617869546f6b656e3a206f776e6572206163636f756e7420646f65736e2774206861766520656e6f7567682062616c616e636520746f206d616b652074686973207472616e736665724554484d617869546f6b656e3a2062616c616e636520666f7220616464726573732068617320616c7265616479206265656e20636c61696d6564a264697066735822122026308732be8e24d51e0bcd20ef97982cdbd2b4d185eb8aeb6cb02aa1c669661464736f6c63430007060033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "claim(address,bytes)": {
        "params": {
          "_owner": "Address to claim tokens for.",
          "_proof": "RLP-encoded merkle trie inclusion proof for the address's account at the               snapshot block height."
        },
        "returns": {
          "_0": "`true` if the function succeeded."
        }
      },
      "slash(bytes)": {
        "params": {
          "_encodedEIP155Tx": "RLP-encoded signed EIP155 transaction."
        },
        "returns": {
          "_0": "`true` if the slashin' was successful."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "claim(address,bytes)": {
        "notice": "Function for redeeming tokens at a 1:1 ratio to ETH at the snapshot block. If you had 1 ETH (= 10^18 wei) at the snapshot, you have 10^18 tokens. I.e., you have the same amount of tokens. Also allows you to claim on behalf of someone else (*you* do the proof, *they* get the money). Perhaps useful if you want to quickly claim and slash."
      },
      "slash(bytes)": {
        "notice": "Slashes an account based on a signed EIP155 transaction with a chain ID other than 1. Simply provide the encoded signed transaction and be rewarded with the heretic's entire (claimed) balance! Will *not* work if the user you're slashing hasn't claimed a balance yet. But you can also claim on behalf of other users if you want to do some slashin'."
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 51,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "totalSupply",
        "offset": 0,
        "slot": "0",
        "type": "t_uint256"
      },
      {
        "astId": 55,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "balances",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_address,t_uint256)"
      },
      {
        "astId": 61,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "allowed",
        "offset": 0,
        "slot": "2",
        "type": "t_mapping(t_address,t_mapping(t_address,t_uint256))"
      },
      {
        "astId": 65,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "claimed",
        "offset": 0,
        "slot": "3",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 69,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "slashed",
        "offset": 0,
        "slot": "4",
        "type": "t_mapping(t_address,t_bool)"
      },
      {
        "astId": 71,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "lockupEndTime",
        "offset": 0,
        "slot": "5",
        "type": "t_uint256"
      },
      {
        "astId": 73,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "snapshotBlockNumber",
        "offset": 0,
        "slot": "6",
        "type": "t_uint256"
      },
      {
        "astId": 75,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "snapshotBlockHash",
        "offset": 0,
        "slot": "7",
        "type": "t_bytes32"
      },
      {
        "astId": 77,
        "contract": "contracts/ETHMaxiToken.sol:ETHMaxiToken",
        "label": "snapshotStateRoot",
        "offset": 0,
        "slot": "8",
        "type": "t_bytes32"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes32": {
        "encoding": "inplace",
        "label": "bytes32",
        "numberOfBytes": "32"
      },
      "t_mapping(t_address,t_bool)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      },
      "t_mapping(t_address,t_mapping(t_address,t_uint256))": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => mapping(address => uint256))",
        "numberOfBytes": "32",
        "value": "t_mapping(t_address,t_uint256)"
      },
      "t_mapping(t_address,t_uint256)": {
        "encoding": "mapping",
        "key": "t_address",
        "label": "mapping(address => uint256)",
        "numberOfBytes": "32",
        "value": "t_uint256"
      },
      "t_uint256": {
        "encoding": "inplace",
        "label": "uint256",
        "numberOfBytes": "32"
      }
    }
  }
}