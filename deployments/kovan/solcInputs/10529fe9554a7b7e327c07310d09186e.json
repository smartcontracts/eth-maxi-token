{
  "language": "Solidity",
  "sources": {
    "contracts/ETHMaxiToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"./libraries/Lib_RLPReader.sol\";\nimport { Lib_SecureMerkleTrie } from \"./libraries/Lib_SecureMerkleTrie.sol\";\nimport { Lib_EIP155Tx } from \"./libraries/Lib_EIP155Tx.sol\";\n\ncontract ETHMaxiToken {\n    using Lib_EIP155Tx for Lib_EIP155Tx.EIP155Tx;\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n\n    event Claimed(\n        address indexed _owner,\n        uint256 _value\n    );\n\n    event Slashed(\n        address indexed _owner,\n        address indexed _slasher,\n        uint256 _value\n    );\n\n    // Just convenient for interfaces.\n    string public constant name = 'Maxi ETH';\n    string public constant symbol = 'mETH';\n    uint256 public constant decimals = 18;\n\n    // Will be dynamic, depends on total ETH supply at time of snapshot. Will increase as more\n    // people claim.\n    uint256 public totalSupply;\n\n    // Balance/allowance mappings.\n    mapping (address => uint256) public balances;\n    mapping (address => mapping (address => uint256)) public allowed;\n    \n    // Make sure people can't claim more than once.\n    mapping (address => bool) public claimed;\n\n    // Make sure people can't get slashed more than once.\n    mapping (address => bool) public slashed;\n\n    // When the lockup ends.\n    uint256 public lockupEndTime;\n\n    // Hashes that people will use to prove their balances.\n    uint256 public snapshotBlockNumber;\n    bytes32 public snapshotBlockHash;\n    bytes32 public snapshotStateRoot;\n\n    constructor(\n        uint256 _lockupPeriod,\n        uint256 _snapshotBlockNumber,\n        bytes memory _snapshotBlockHeader\n    ) {\n        lockupEndTime = block.timestamp + _lockupPeriod;\n        snapshotBlockNumber = _snapshotBlockNumber;\n        snapshotBlockHash = blockhash(_snapshotBlockNumber);\n\n        // // Just a safety measure.\n        // require(\n        //     keccak256(_snapshotBlockHeader) == snapshotBlockHash,\n        //     \"ETHMaxiToken: block header does not match snapshot block hash\"\n        // );\n\n        // Decode the block header in order to pull out the state root.\n        Lib_RLPReader.RLPItem[] memory blockHeader = Lib_RLPReader.readList(\n            _snapshotBlockHeader\n        );\n        snapshotStateRoot = Lib_RLPReader.readBytes32(blockHeader[3]);\n    }\n\n    /**\n     * We use a lockup period to prevent people from claiming and then transferring their tokens to\n     * avoid getting slashed. Simple modifier for checking this condition.\n     */\n    modifier onlyAfterLockup() {\n        require(\n            block.timestamp > lockupEndTime,\n            \"ETHMaxiToken: lockup hasn't ended yet, nerd\"\n        );\n        _;\n    }\n\n    /**\n     * Function for redeeming tokens at a 1:1 ratio to ETH at the snapshot block. If you had 1 ETH\n     * (= 10^18 wei) at the snapshot, you have 10^18 tokens. I.e., you have the same amount of\n     * tokens. Also allows you to claim on behalf of someone else (*you* do the proof, *they* get\n     * the money). Perhaps useful if you want to quickly claim and slash.\n     * @param _owner Address to claim tokens for.\n     * @param _proof RLP-encoded merkle trie inclusion proof for the address's account at the\n     *               snapshot block height.\n     * @return `true` if the function succeeded.\n     */\n    function claim(\n        address _owner,\n        bytes memory _proof\n    )\n        public\n        returns (\n            bool\n        )\n    {\n        // You can only claim once per address.\n        require(\n            claimed[_owner] == false,\n            \"ETHMaxiToken: balance for address has already been claimed\"\n        );\n\n        // Pull out the encoded account from the merkle trie proof.\n        (bool exists, bytes memory encodedAccount) = Lib_SecureMerkleTrie.get(\n            abi.encodePacked(_owner),\n            _proof,\n            snapshotStateRoot\n        );\n\n        require(\n            exists == true,\n            \"ETHMaxiToken: bad eth merkle proof\"\n        );\n\n        // Decode account to get its balance.\n        Lib_RLPReader.RLPItem[] memory account = Lib_RLPReader.readList(\n            encodedAccount\n        );\n        uint256 amount = Lib_RLPReader.readUint256(account[1]);\n\n        // Mark as claimed and give out the balance.\n        claimed[_owner] = true;\n        balances[_owner] = amount;\n\n        emit Transfer(address(0), _owner, amount);\n        emit Claimed(_owner, amount);\n        return true;\n    }\n\n    /**\n     * Slashes an account based on a signed EIP155 transaction with a chain ID other than 1. Simply\n     * provide the encoded signed transaction and be rewarded with the heretic's entire (claimed)\n     * balance! Will *not* work if the user you're slashing hasn't claimed a balance yet. But you\n     * can also claim on behalf of other users if you want to do some slashin'.\n     * @param _encodedEIP155Tx RLP-encoded signed EIP155 transaction.\n     * @return `true` if the slashin' was successful.\n     */\n    function slash(\n        bytes memory _encodedEIP155Tx\n    )\n        public\n        returns (\n            bool\n        )\n    {\n        Lib_EIP155Tx.EIP155Tx memory transaction = Lib_EIP155Tx.decode(\n            _encodedEIP155Tx,\n            1 // chain id of ethereum\n        );\n\n        address owner = transaction.sender();\n\n        require(\n            claimed[owner] == true,\n            \"ETHMaxiToken: can't slash because the user hasn't claimed\"\n        );\n\n        require(\n            slashed[owner] == false,\n            \"ETHMaxiToken: address has already been slashed\"\n        );\n\n        uint256 amount = balances[owner];\n\n        slashed[owner] = true;\n        balances[msg.sender] += amount;\n        balances[owner] = 0;\n        emit Transfer(owner, msg.sender, amount);\n        emit Slashed(owner, msg.sender, amount);\n        return true;\n    }\n\n    function transfer(\n        address _to,\n        uint256 _value\n    )\n        public\n        onlyAfterLockup\n        returns (\n            bool\n        )\n    {\n        require(\n            balances[msg.sender] >= _value,\n            \"ETHMaxiToken: you don't have enough balance to make this transfer\"\n        );\n\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _value\n    )\n        public\n        onlyAfterLockup\n        returns (\n            bool\n        )\n    {\n        require(\n            allowed[_from][msg.sender] >= _value,\n            \"ETHMaxiToken: not enough allowance\"\n        );\n\n        require(\n            balances[_from] >= _value,\n            \"ETHMaxiToken: owner account doesn't have enough balance to make this transfer\"\n        );\n\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        allowed[_from][msg.sender] -= _value;\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function balanceOf(\n        address _owner\n    )\n        public\n        view\n        returns (\n            uint256\n        )\n    {\n        return balances[_owner];\n    }\n\n    function approve(\n        address _spender,\n        uint256 _value\n    )\n        public\n        returns (\n            bool\n        )\n    {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(\n        address _owner,\n        address _spender\n    )\n        public\n        view\n        returns (\n            uint256\n        )\n    {\n        return allowed[_owner][_spender];\n    }\n}\n"
    },
    "contracts/libraries/Lib_RLPReader.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_RLPReader\n * @dev Adapted from \"RLPReader\" by Hamdi Allam (hamdi.allam97@gmail.com).\n */\nlibrary Lib_RLPReader {\n\n    /*************\n     * Constants *\n     *************/\n\n    uint256 constant internal MAX_LIST_LENGTH = 32;\n\n\n    /*********\n     * Enums *\n     *********/\n\n    enum RLPItemType {\n        DATA_ITEM,\n        LIST_ITEM\n    }\n\n    \n    /***********\n     * Structs *\n     ***********/\n\n    struct RLPItem {\n        uint256 length;\n        uint256 ptr;\n    }\n    \n\n    /**********************\n     * Internal Functions *\n     **********************/\n    \n    /**\n     * Converts bytes to a reference to memory position and length.\n     * @param _in Input bytes to convert.\n     * @return Output memory reference.\n     */\n    function toRLPItem(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem memory\n        )\n    {\n        uint256 ptr;\n        assembly {\n            ptr := add(_in, 32)\n        }\n\n        return RLPItem({\n            length: _in.length,\n            ptr: ptr\n        });\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        (\n            uint256 listOffset,\n            ,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.LIST_ITEM,\n            \"Invalid RLP list value.\"\n        );\n\n        // Solidity in-memory arrays can't be increased in size, but *can* be decreased in size by\n        // writing to the length. Since we can't know the number of RLP items without looping over\n        // the entire input, we'd have to loop twice to accurately size this array. It's easier to\n        // simply set a reasonable maximum list length and decrease the size before we finish.\n        RLPItem[] memory out = new RLPItem[](MAX_LIST_LENGTH);\n\n        uint256 itemCount = 0;\n        uint256 offset = listOffset;\n        while (offset < _in.length) {\n            require(\n                itemCount < MAX_LIST_LENGTH,\n                \"Provided RLP list exceeds max list length.\"\n            );\n\n            (\n                uint256 itemOffset,\n                uint256 itemLength,\n            ) = _decodeLength(RLPItem({\n                length: _in.length - offset,\n                ptr: _in.ptr + offset\n            }));\n\n            out[itemCount] = RLPItem({\n                length: itemLength + itemOffset,\n                ptr: _in.ptr + offset\n            });\n\n            itemCount += 1;\n            offset += itemOffset + itemLength;\n        }\n\n        // Decrease the array size to match the actual item count.\n        assembly {\n            mstore(out, itemCount)\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP list value into a list of RLP items.\n     * @param _in RLP list value.\n     * @return Decoded RLP list items.\n     */\n    function readList(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            RLPItem[] memory\n        )\n    {\n        return readList(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes value.\"\n        );\n\n        return _copy(_in.ptr, itemOffset, itemLength);\n    }\n\n    /**\n     * Reads an RLP bytes value into bytes.\n     * @param _in RLP bytes value.\n     * @return Decoded bytes.\n     */\n    function readBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return readBytes(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return string(readBytes(_in));\n    }\n\n    /**\n     * Reads an RLP string value into a string.\n     * @param _in RLP string value.\n     * @return Decoded string.\n     */\n    function readString(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            string memory\n        )\n    {\n        return readString(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        require(\n            _in.length <= 33,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        (\n            uint256 itemOffset,\n            uint256 itemLength,\n            RLPItemType itemType\n        ) = _decodeLength(_in);\n\n        require(\n            itemType == RLPItemType.DATA_ITEM,\n            \"Invalid RLP bytes32 value.\"\n        );\n\n        uint256 ptr = _in.ptr + itemOffset;\n        bytes32 out;\n        assembly {\n            out := mload(ptr)\n\n            // Shift the bytes over to match the item size.\n            if lt(itemLength, 32) {\n                out := div(out, exp(256, sub(32, itemLength)))\n            }\n        }\n\n        return out;\n    }\n\n    /**\n     * Reads an RLP bytes32 value into a bytes32.\n     * @param _in RLP bytes32 value.\n     * @return Decoded bytes32.\n     */\n    function readBytes32(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return readBytes32(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return uint256(readBytes32(_in));\n    }\n\n    /**\n     * Reads an RLP uint256 value into a uint256.\n     * @param _in RLP uint256 value.\n     * @return Decoded uint256.\n     */\n    function readUint256(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            uint256\n        )\n    {\n        return readUint256(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        require(\n            _in.length == 1,\n            \"Invalid RLP boolean value.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 out;\n        assembly {\n            out := byte(0, mload(ptr))\n        }\n\n        return out != 0;\n    }\n\n    /**\n     * Reads an RLP bool value into a bool.\n     * @param _in RLP bool value.\n     * @return Decoded bool.\n     */\n    function readBool(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bool\n        )\n    {\n        return readBool(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        if (_in.length == 1) {\n            return address(0);\n        }\n\n        require(\n            _in.length == 21,\n            \"Invalid RLP address value.\"\n        );\n\n        return address(readUint256(_in));\n    }\n\n    /**\n     * Reads an RLP address value into a address.\n     * @param _in RLP address value.\n     * @return Decoded address.\n     */\n    function readAddress(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return readAddress(\n            toRLPItem(_in)\n        );\n    }\n\n    /**\n     * Reads the raw bytes of an RLP item.\n     * @param _in RLP item to read.\n     * @return Raw RLP bytes.\n     */\n    function readRawBytes(\n        RLPItem memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Decodes the length of an RLP item.\n     * @param _in RLP item to decode.\n     * @return Offset of the encoded data.\n     * @return Length of the encoded data.\n     * @return RLP item type (LIST_ITEM or DATA_ITEM).\n     */\n    function _decodeLength(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            uint256,\n            uint256,\n            RLPItemType\n        )\n    {\n        require(\n            _in.length > 0,\n            \"RLP item cannot be null.\"\n        );\n\n        uint256 ptr = _in.ptr;\n        uint256 prefix;\n        assembly {\n            prefix := byte(0, mload(ptr))\n        }\n\n        if (prefix <= 0x7f) {\n            // Single byte.\n\n            return (0, 1, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xb7) {\n            // Short string.\n\n            uint256 strLen = prefix - 0x80;\n            \n            require(\n                _in.length > strLen,\n                \"Invalid RLP short string.\"\n            );\n\n            return (1, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xbf) {\n            // Long string.\n            uint256 lenOfStrLen = prefix - 0xb7;\n\n            require(\n                _in.length > lenOfStrLen,\n                \"Invalid RLP long string length.\"\n            );\n\n            uint256 strLen;\n            assembly {\n                // Pick out the string length.\n                strLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfStrLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfStrLen + strLen,\n                \"Invalid RLP long string.\"\n            );\n\n            return (1 + lenOfStrLen, strLen, RLPItemType.DATA_ITEM);\n        } else if (prefix <= 0xf7) {\n            // Short list.\n            uint256 listLen = prefix - 0xc0;\n\n            require(\n                _in.length > listLen,\n                \"Invalid RLP short list.\"\n            );\n\n            return (1, listLen, RLPItemType.LIST_ITEM);\n        } else {\n            // Long list.\n            uint256 lenOfListLen = prefix - 0xf7;\n\n            require(\n                _in.length > lenOfListLen,\n                \"Invalid RLP long list length.\"\n            );\n\n            uint256 listLen;\n            assembly {\n                // Pick out the list length.\n                listLen := div(\n                    mload(add(ptr, 1)),\n                    exp(256, sub(32, lenOfListLen))\n                )\n            }\n\n            require(\n                _in.length > lenOfListLen + listLen,\n                \"Invalid RLP long list.\"\n            );\n\n            return (1 + lenOfListLen, listLen, RLPItemType.LIST_ITEM);\n        }\n    }\n\n    /**\n     * Copies the bytes from a memory location.\n     * @param _src Pointer to the location to read from.\n     * @param _offset Offset to start reading from.\n     * @param _length Number of bytes to read.\n     * @return Copied bytes.\n     */\n    function _copy(\n        uint256 _src,\n        uint256 _offset,\n        uint256 _length\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes memory out = new bytes(_length);\n        if (out.length == 0) {\n            return out;\n        }\n\n        uint256 src = _src + _offset;\n        uint256 dest;\n        assembly {\n            dest := add(out, 32)\n        }\n\n        // Copy over as many complete words as we can.\n        for (uint256 i = 0; i < _length / 32; i++) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n\n            src += 32;\n            dest += 32;\n        }\n\n        // Pick out the remaining bytes.\n        uint256 mask = 256 ** (32 - (_length % 32)) - 1;\n        assembly {\n            mstore(\n                dest,\n                or(\n                    and(mload(src), not(mask)),\n                    and(mload(dest), mask)\n                )\n            )\n        }\n\n        return out;\n    }\n\n    /**\n     * Copies an RLP item into bytes.\n     * @param _in RLP item to copy.\n     * @return Copied bytes.\n     */\n    function _copy(\n        RLPItem memory _in\n    )\n        private\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        return _copy(_in.ptr, 0, _in.length);\n    }\n}\n"
    },
    "contracts/libraries/Lib_SecureMerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_MerkleTrie } from \"./Lib_MerkleTrie.sol\";\n\n/**\n * @title Lib_SecureMerkleTrie\n */\nlibrary Lib_SecureMerkleTrie {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _verified\n        )\n    {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.verifyInclusionProof(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Verifies a proof that a given key is *not* present in\n     * the Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the key is not present in the trie, `false` otherwise.\n     */\n    function verifyExclusionProof(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _verified\n        )\n    {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.verifyExclusionProof(key, _proof, _root);\n    }\n\n    /**\n     * @notice Updates a Merkle trie and returns a new root hash.\n     * @param _key Key of the node to update, as a hex string.\n     * @param _value Value of the node to update, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node. If the key exists, we can simply update the value.\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _updatedRoot Root hash of the newly constructed trie.\n     */\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bytes32 _updatedRoot\n        )\n    {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.update(key, _value, _proof, _root);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _exists,\n            bytes memory _value\n        )\n    {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.get(key, _proof, _root);\n    }\n\n    /**\n     * Computes the root hash for a trie with a single node.\n     * @param _key Key for the single node.\n     * @param _value Value for the single node.\n     * @return _updatedRoot Hash of the trie.\n     */\n    function getSingleNodeRootHash(\n        bytes memory _key,\n        bytes memory _value\n    )\n        internal\n        pure\n        returns (\n            bytes32 _updatedRoot\n        )\n    {\n        bytes memory key = _getSecureKey(_key);\n        return Lib_MerkleTrie.getSingleNodeRootHash(key, _value);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Computes the secure counterpart to a key.\n     * @param _key Key to get a secure key from.\n     * @return _secureKey Secure version of the key.\n     */\n    function _getSecureKey(\n        bytes memory _key\n    )\n        private\n        pure\n        returns (\n            bytes memory _secureKey\n        )\n    {\n        return abi.encodePacked(keccak256(_key));\n    }\n}\n"
    },
    "contracts/libraries/Lib_EIP155Tx.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_RLPReader } from \"./Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"./Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_EIP155Tx\n * @dev A simple library for dealing with the transaction type defined by EIP155:\n *      https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n */\nlibrary Lib_EIP155Tx {\n\n    /***********\n     * Structs *\n     ***********/\n\n    // Struct representing an EIP155 transaction. See EIP link above for more information.\n    struct EIP155Tx {\n        // These fields correspond to the actual RLP-encoded fields specified by EIP155.\n        uint256 nonce;\n        uint256 gasPrice;\n        uint256 gasLimit;\n        address to;\n        uint256 value;\n        bytes data;\n        uint8 v;\n        bytes32 r;\n        bytes32 s;\n\n        // Chain ID to associate this transaction with. Used all over the place, seemed easier to\n        // set this once when we create the transaction rather than providing it as an input to\n        // each function. I don't see a strong need to have a transaction with a mutable chain ID.\n        uint256 chainId;\n\n        // The ECDSA \"recovery parameter,\" should always be 0 or 1. EIP155 specifies that:\n        // `v = {0,1} + CHAIN_ID * 2 + 35`\n        // Where `{0,1}` is a stand in for our `recovery_parameter`. Now computing our formula for\n        // the recovery parameter:\n        // 1. `v = {0,1} + CHAIN_ID * 2 + 35`\n        // 2. `v = recovery_parameter + CHAIN_ID * 2 + 35`\n        // 3. `v - CHAIN_ID * 2 - 35 = recovery_parameter`\n        // So we're left with the final formula:\n        // `recovery_parameter = v - CHAIN_ID * 2 - 35`\n        // NOTE: This variable is a uint8 because `v` is inherently limited to a uint8. If we\n        // didn't use a uint8, then recovery_parameter would always be a negative number for chain\n        // IDs greater than 110 (`255 - 110 * 2 - 35 = 0`). So we need to wrap around to support\n        // anything larger.\n        uint8 recoveryParam; \n\n        // Whether or not the transaction is a creation. Necessary because we can't make an address\n        // \"nil\". Using the zero address creates a potential conflict if the user did actually\n        // intend to send a transaction to the zero address.\n        bool isCreate;       \n    }\n\n    // Lets us use nicer syntax.\n    using Lib_EIP155Tx for EIP155Tx;\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * Decodes an EIP155 transaction and attaches a given Chain ID.\n     * Transaction *must* be RLP-encoded.\n     * @param _encoded RLP-encoded EIP155 transaction.\n     * @param _chainId Chain ID to assocaite with this transaction.\n     * @return Parsed transaction.\n     */\n    function decode(\n        bytes memory _encoded,\n        uint256 _chainId\n    )\n        internal\n        pure\n        returns (\n            EIP155Tx memory\n        )\n    {\n        Lib_RLPReader.RLPItem[] memory decoded = Lib_RLPReader.readList(_encoded);\n\n        // Note formula above about how recoveryParam is computed.\n        uint8 v = uint8(Lib_RLPReader.readUint256(decoded[6]));\n        uint8 recoveryParam = uint8(v - 2 * _chainId - 35);\n\n        require(\n            recoveryParam < 2,\n            \"Lib_EIP155Tx: invalid chain id\"\n        );\n\n        // Creations can be detected by looking at the byte length here.\n        bool isCreate = Lib_RLPReader.readBytes(decoded[3]).length == 0;\n\n        return EIP155Tx({\n            nonce: Lib_RLPReader.readUint256(decoded[0]),\n            gasPrice: Lib_RLPReader.readUint256(decoded[1]),\n            gasLimit: Lib_RLPReader.readUint256(decoded[2]),\n            to: Lib_RLPReader.readAddress(decoded[3]),\n            value: Lib_RLPReader.readUint256(decoded[4]),\n            data: Lib_RLPReader.readBytes(decoded[5]),\n            v: v,\n            r: Lib_RLPReader.readBytes32(decoded[7]),\n            s: Lib_RLPReader.readBytes32(decoded[8]),\n            chainId: _chainId,\n            recoveryParam: recoveryParam,\n            isCreate: isCreate\n        });\n    }\n\n    /**\n     * Encodes an EIP155 transaction into RLP.\n     * @param _transaction EIP155 transaction to encode.\n     * @param _includeSignature Whether or not to encode the signature.\n     * @return RLP-encoded transaction.\n     */\n    function encode(\n        EIP155Tx memory _transaction,\n        bool _includeSignature\n    )\n        internal\n        pure\n        returns (\n            bytes memory\n        )\n    {\n        bytes[] memory raw = new bytes[](9);\n\n        raw[0] = Lib_RLPWriter.writeUint(_transaction.nonce);\n        raw[1] = Lib_RLPWriter.writeUint(_transaction.gasPrice);\n        raw[2] = Lib_RLPWriter.writeUint(_transaction.gasLimit);\n\n        // We write the encoding of empty bytes when the transaction is a creation, *not* the zero\n        // address as one might assume.\n        if (_transaction.isCreate) {\n            raw[3] = Lib_RLPWriter.writeBytes('');\n        } else {\n            raw[3] = Lib_RLPWriter.writeAddress(_transaction.to);\n        }\n\n        raw[4] = Lib_RLPWriter.writeUint(_transaction.value);\n        raw[5] = Lib_RLPWriter.writeBytes(_transaction.data);\n\n        if (_includeSignature) {\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.v);\n            raw[7] = Lib_RLPWriter.writeBytes32(_transaction.r);\n            raw[8] = Lib_RLPWriter.writeBytes32(_transaction.s);\n        } else {\n            // Chain ID *is* included in the unsigned transaction.\n            raw[6] = Lib_RLPWriter.writeUint(_transaction.chainId); \n            raw[7] = Lib_RLPWriter.writeBytes('');\n            raw[8] = Lib_RLPWriter.writeBytes('');\n        }\n\n        return Lib_RLPWriter.writeList(raw);\n    }\n\n    /**\n     * Computes the hash of an EIP155 transaction. Assumes that you don't want to include the\n     * signature in this hash because that's a very uncommon usecase. If you really want to include\n     * the signature, just encode with the signature and take the hash yourself.\n     */\n    function hash(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            bytes32\n        )\n    {\n        return keccak256(\n            _transaction.encode(false)\n        );\n    }\n\n    /**\n     * Computes the sender of an EIP155 transaction.\n     * @param _transaction EIP155 transaction to get a sender for.\n     * @return Address corresponding to the private key that signed this transaction.\n     */\n    function sender(\n        EIP155Tx memory _transaction\n    )\n        internal\n        pure\n        returns (\n            address\n        )\n    {\n        return ecrecover(\n            _transaction.hash(),\n            _transaction.recoveryParam + 27,\n            _transaction.r,\n            _transaction.s\n        );\n    }\n}\n"
    },
    "contracts/libraries/Lib_MerkleTrie.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"./Lib_BytesUtils.sol\";\nimport { Lib_RLPReader } from \"./Lib_RLPReader.sol\";\nimport { Lib_RLPWriter } from \"./Lib_RLPWriter.sol\";\n\n/**\n * @title Lib_MerkleTrie\n */\nlibrary Lib_MerkleTrie {\n\n    /*******************\n     * Data Structures *\n     *******************/\n\n    enum NodeType {\n        BranchNode,\n        ExtensionNode,\n        LeafNode\n    }\n\n    struct TrieNode {\n        bytes encoded;\n        Lib_RLPReader.RLPItem[] decoded;\n    }\n\n\n    /**********************\n     * Contract Constants *\n     **********************/\n\n    // TREE_RADIX determines the number of elements per branch node.\n    uint256 constant TREE_RADIX = 16;\n    // Branch nodes have TREE_RADIX elements plus an additional `value` slot.\n    uint256 constant BRANCH_NODE_LENGTH = TREE_RADIX + 1;\n    // Leaf nodes and extension nodes always have two elements, a `path` and a `value`.\n    uint256 constant LEAF_OR_EXTENSION_NODE_LENGTH = 2;\n\n    // Prefixes are prepended to the `path` within a leaf or extension node and\n    // allow us to differentiate between the two node types. `ODD` or `EVEN` is\n    // determined by the number of nibbles within the unprefixed `path`. If the\n    // number of nibbles if even, we need to insert an extra padding nibble so\n    // the resulting prefixed `path` has an even number of nibbles.\n    uint8 constant PREFIX_EXTENSION_EVEN = 0;\n    uint8 constant PREFIX_EXTENSION_ODD = 1;\n    uint8 constant PREFIX_LEAF_EVEN = 2;\n    uint8 constant PREFIX_LEAF_ODD = 3;\n\n    // Just a utility constant. RLP represents `NULL` as 0x80.\n    bytes1 constant RLP_NULL = bytes1(0x80);\n    bytes constant RLP_NULL_BYTES = hex'80';\n    bytes32 constant internal KECCAK256_RLP_NULL_BYTES = keccak256(RLP_NULL_BYTES);\n\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * @notice Verifies a proof that a given key/value pair is present in the\n     * Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _value Value of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the desired node. Unlike\n     * traditional Merkle trees, this proof is executed top-down and consists\n     * of a list of RLP-encoded nodes that make a path down to the target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the k/v pair exists in the trie, `false` otherwise.\n     */\n    function verifyInclusionProof(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _verified\n        )\n    {\n        (\n            bool exists,\n            bytes memory value\n        ) = get(_key, _proof, _root);\n\n        return (\n            exists && Lib_BytesUtils.equal(_value, value)\n        );\n    }\n\n    /**\n     * @notice Verifies a proof that a given key is *not* present in\n     * the Merkle trie.\n     * @param _key Key of the node to search for, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _verified `true` if the key is absent in the trie, `false` otherwise.\n     */\n    function verifyExclusionProof(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _verified\n        )\n    {\n        (\n            bool exists,\n        ) = get(_key, _proof, _root);\n\n        return exists == false;\n    }\n\n    /**\n     * @notice Updates a Merkle trie and returns a new root hash.\n     * @param _key Key of the node to update, as a hex string.\n     * @param _value Value of the node to update, as a hex string.\n     * @param _proof Merkle trie inclusion proof for the node *nearest* the\n     * target node. If the key exists, we can simply update the value.\n     * Otherwise, we need to modify the trie to handle the new k/v pair.\n     * @param _root Known root of the Merkle trie. Used to verify that the\n     * included proof is correctly constructed.\n     * @return _updatedRoot Root hash of the newly constructed trie.\n     */\n    function update(\n        bytes memory _key,\n        bytes memory _value,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bytes32 _updatedRoot\n        )\n    {\n        // Special case when inserting the very first node.\n        if (_root == KECCAK256_RLP_NULL_BYTES) {\n            return getSingleNodeRootHash(_key, _value);\n        }\n\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, ) = _walkNodePath(proof, _key, _root);\n        TrieNode[] memory newPath = _getNewPath(proof, pathLength, keyRemainder, _value);\n\n        return _getUpdatedTrieRoot(newPath, _key);\n    }\n\n    /**\n     * @notice Retrieves the value associated with a given key.\n     * @param _key Key to search for, as hex bytes.\n     * @param _proof Merkle trie inclusion proof for the key.\n     * @param _root Known root of the Merkle trie.\n     * @return _exists Whether or not the key exists.\n     * @return _value Value of the key if it exists.\n     */\n    function get(\n        bytes memory _key,\n        bytes memory _proof,\n        bytes32 _root\n    )\n        internal\n        pure\n        returns (\n            bool _exists,\n            bytes memory _value\n        )\n    {\n        TrieNode[] memory proof = _parseProof(_proof);\n        (uint256 pathLength, bytes memory keyRemainder, bool isFinalNode) = _walkNodePath(proof, _key, _root);\n\n        bool exists = keyRemainder.length == 0;\n\n        require(\n            exists || isFinalNode,\n            \"Provided proof is invalid.\"\n        );\n\n        bytes memory value = exists ? _getNodeValue(proof[pathLength - 1]) : bytes('');\n\n        return (\n            exists,\n            value\n        );\n    }\n\n    /**\n     * Computes the root hash for a trie with a single node.\n     * @param _key Key for the single node.\n     * @param _value Value for the single node.\n     * @return _updatedRoot Hash of the trie.\n     */\n    function getSingleNodeRootHash(\n        bytes memory _key,\n        bytes memory _value\n    )\n        internal\n        pure\n        returns (\n            bytes32 _updatedRoot\n        )\n    {\n        return keccak256(_makeLeafNode(\n            Lib_BytesUtils.toNibbles(_key),\n            _value\n        ).encoded);\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * @notice Walks through a proof using a provided key.\n     * @param _proof Inclusion proof to walk through.\n     * @param _key Key to use for the walk.\n     * @param _root Known root of the trie.\n     * @return _pathLength Length of the final path\n     * @return _keyRemainder Portion of the key remaining after the walk.\n     * @return _isFinalNode Whether or not we've hit a dead end.\n     */\n    function _walkNodePath(\n        TrieNode[] memory _proof,\n        bytes memory _key,\n        bytes32 _root\n    )\n        private\n        pure\n        returns (\n            uint256 _pathLength,\n            bytes memory _keyRemainder,\n            bool _isFinalNode\n        )\n    {\n        uint256 pathLength = 0;\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        bytes32 currentNodeID = _root;\n        uint256 currentKeyIndex = 0;\n        uint256 currentKeyIncrement = 0;\n        TrieNode memory currentNode;\n\n        // Proof is top-down, so we start at the first element (root).\n        for (uint256 i = 0; i < _proof.length; i++) {\n            currentNode = _proof[i];\n            currentKeyIndex += currentKeyIncrement;\n\n            // Keep track of the proof elements we actually need.\n            // It's expensive to resize arrays, so this simply reduces gas costs.\n            pathLength += 1;\n\n            if (currentKeyIndex == 0) {\n                // First proof element is always the root node.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid root hash\"\n                );\n            } else if (currentNode.encoded.length >= 32) {\n                // Nodes 32 bytes or larger are hashed inside branch nodes.\n                require(\n                    keccak256(currentNode.encoded) == currentNodeID,\n                    \"Invalid large internal hash\"\n                );\n            } else {\n                // Nodes smaller than 31 bytes aren't hashed.\n                require(\n                    Lib_BytesUtils.toBytes32(currentNode.encoded) == currentNodeID,\n                    \"Invalid internal node hash\"\n                );\n            }\n\n            if (currentNode.decoded.length == BRANCH_NODE_LENGTH) {\n                if (currentKeyIndex == key.length) {\n                    // We've hit the end of the key, meaning the value should be within this branch node.\n                    break;\n                } else {\n                    // We're not at the end of the key yet.\n                    // Figure out what the next node ID should be and continue.\n                    uint8 branchKey = uint8(key[currentKeyIndex]);\n                    Lib_RLPReader.RLPItem memory nextNode = currentNode.decoded[branchKey];\n                    currentNodeID = _getNodeID(nextNode);\n                    currentKeyIncrement = 1;\n                    continue;\n                }\n            } else if (currentNode.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n                bytes memory path = _getNodePath(currentNode);\n                uint8 prefix = uint8(path[0]);\n                uint8 offset = 2 - prefix % 2;\n                bytes memory pathRemainder = Lib_BytesUtils.slice(path, offset);\n                bytes memory keyRemainder = Lib_BytesUtils.slice(key, currentKeyIndex);\n                uint256 sharedNibbleLength = _getSharedNibbleLength(pathRemainder, keyRemainder);\n\n                if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                    if (\n                        pathRemainder.length == sharedNibbleLength &&\n                        keyRemainder.length == sharedNibbleLength\n                    ) {\n                        // The key within this leaf matches our key exactly.\n                        // Increment the key index to reflect that we have no remainder.\n                        currentKeyIndex += sharedNibbleLength;\n                    }\n\n                    // We've hit a leaf node, so our next node should be NULL.\n                    currentNodeID = bytes32(RLP_NULL);\n                    break;\n                } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                    if (sharedNibbleLength == 0) {\n                        // Our extension node doesn't share any part of our key.\n                        // We've hit the end of this path, updates will need to modify this extension.\n                        currentNodeID = bytes32(RLP_NULL);\n                        break;\n                    } else {\n                        // Our extension shares some nibbles.\n                        // Carry on to the next node.\n                        currentNodeID = _getNodeID(currentNode.decoded[1]);\n                        currentKeyIncrement = sharedNibbleLength;\n                        continue;\n                    }\n                } else {\n                    revert(\"Received a node with an unknown prefix\");\n                }\n            } else {\n                revert(\"Received an unparseable node.\");\n            }\n        }\n\n        // If our node ID is NULL, then we're at a dead end.\n        bool isFinalNode = currentNodeID == bytes32(RLP_NULL);\n        return (pathLength, Lib_BytesUtils.slice(key, currentKeyIndex), isFinalNode);\n    }\n\n    /**\n     * @notice Creates new nodes to support a k/v pair insertion into a given\n     * Merkle trie path.\n     * @param _path Path to the node nearest the k/v pair.\n     * @param _pathLength Length of the path. Necessary because the provided\n     * path may include additional nodes (e.g., it comes directly from a proof)\n     * and we can't resize in-memory arrays without costly duplication.\n     * @param _keyRemainder Portion of the initial key that must be inserted\n     * into the trie.\n     * @param _value Value to insert at the given key.\n     * @return _newPath A new path with the inserted k/v pair and extra supporting nodes.\n     */\n    function _getNewPath(\n        TrieNode[] memory _path,\n        uint256 _pathLength,\n        bytes memory _keyRemainder,\n        bytes memory _value\n    )\n        private\n        pure\n        returns (\n            TrieNode[] memory _newPath\n        )\n    {\n        bytes memory keyRemainder = _keyRemainder;\n\n        // Most of our logic depends on the status of the last node in the path.\n        TrieNode memory lastNode = _path[_pathLength - 1];\n        NodeType lastNodeType = _getNodeType(lastNode);\n\n        // Create an array for newly created nodes.\n        // We need up to three new nodes, depending on the contents of the last node.\n        // Since array resizing is expensive, we'll keep track of the size manually.\n        // We're using an explicit `totalNewNodes += 1` after insertions for clarity.\n        TrieNode[] memory newNodes = new TrieNode[](3);\n        uint256 totalNewNodes = 0;\n\n        if (keyRemainder.length == 0 && lastNodeType == NodeType.LeafNode) {\n            // We've found a leaf node with the given key.\n            // Simply need to update the value of the node to match.\n            newNodes[totalNewNodes] = _makeLeafNode(_getNodeKey(lastNode), _value);\n            totalNewNodes += 1;\n        } else if (lastNodeType == NodeType.BranchNode) {\n            if (keyRemainder.length == 0) {\n                // We've found a branch node with the given key.\n                // Simply need to update the value of the node to match.\n                newNodes[totalNewNodes] = _editBranchValue(lastNode, _value);\n                totalNewNodes += 1;\n            } else {\n                // We've found a branch node, but it doesn't contain our key.\n                // Reinsert the old branch for now.\n                newNodes[totalNewNodes] = lastNode;\n                totalNewNodes += 1;\n                // Create a new leaf node, slicing our remainder since the first byte points\n                // to our branch node.\n                newNodes[totalNewNodes] = _makeLeafNode(Lib_BytesUtils.slice(keyRemainder, 1), _value);\n                totalNewNodes += 1;\n            }\n        } else {\n            // Our last node is either an extension node or a leaf node with a different key.\n            bytes memory lastNodeKey = _getNodeKey(lastNode);\n            uint256 sharedNibbleLength = _getSharedNibbleLength(lastNodeKey, keyRemainder);\n\n            if (sharedNibbleLength != 0) {\n                // We've got some shared nibbles between the last node and our key remainder.\n                // We'll need to insert an extension node that covers these shared nibbles.\n                bytes memory nextNodeKey = Lib_BytesUtils.slice(lastNodeKey, 0, sharedNibbleLength);\n                newNodes[totalNewNodes] = _makeExtensionNode(nextNodeKey, _getNodeHash(_value));\n                totalNewNodes += 1;\n\n                // Cut down the keys since we've just covered these shared nibbles.\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, sharedNibbleLength);\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, sharedNibbleLength);\n            }\n\n            // Create an empty branch to fill in.\n            TrieNode memory newBranch = _makeEmptyBranchNode();\n\n            if (lastNodeKey.length == 0) {\n                // Key remainder was larger than the key for our last node.\n                // The value within our last node is therefore going to be shifted into\n                // a branch value slot.\n                newBranch = _editBranchValue(newBranch, _getNodeValue(lastNode));\n            } else {\n                // Last node key was larger than the key remainder.\n                // We're going to modify some index of our branch.\n                uint8 branchKey = uint8(lastNodeKey[0]);\n                // Move on to the next nibble.\n                lastNodeKey = Lib_BytesUtils.slice(lastNodeKey, 1);\n\n                if (lastNodeType == NodeType.LeafNode) {\n                    // We're dealing with a leaf node.\n                    // We'll modify the key and insert the old leaf node into the branch index.\n                    TrieNode memory modifiedLastNode = _makeLeafNode(lastNodeKey, _getNodeValue(lastNode));\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeHash(modifiedLastNode.encoded));\n                } else if (lastNodeKey.length != 0) {\n                    // We're dealing with a shrinking extension node.\n                    // We need to modify the node to decrease the size of the key.\n                    TrieNode memory modifiedLastNode = _makeExtensionNode(lastNodeKey, _getNodeValue(lastNode));\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeHash(modifiedLastNode.encoded));\n                } else {\n                    // We're dealing with an unnecessary extension node.\n                    // We're going to delete the node entirely.\n                    // Simply insert its current value into the branch index.\n                    newBranch = _editBranchIndex(newBranch, branchKey, _getNodeValue(lastNode));\n                }\n            }\n\n            if (keyRemainder.length == 0) {\n                // We've got nothing left in the key remainder.\n                // Simply insert the value into the branch value slot.\n                newBranch = _editBranchValue(newBranch, _value);\n                // Push the branch into the list of new nodes.\n                newNodes[totalNewNodes] = newBranch;\n                totalNewNodes += 1;\n            } else {\n                // We've got some key remainder to work with.\n                // We'll be inserting a leaf node into the trie.\n                // First, move on to the next nibble.\n                keyRemainder = Lib_BytesUtils.slice(keyRemainder, 1);\n                // Push the branch into the list of new nodes.\n                newNodes[totalNewNodes] = newBranch;\n                totalNewNodes += 1;\n                // Push a new leaf node for our k/v pair.\n                newNodes[totalNewNodes] = _makeLeafNode(keyRemainder, _value);\n                totalNewNodes += 1;\n            }\n        }\n\n        // Finally, join the old path with our newly created nodes.\n        // Since we're overwriting the last node in the path, we use `_pathLength - 1`.\n        return _joinNodeArrays(_path, _pathLength - 1, newNodes, totalNewNodes);\n    }\n\n    /**\n     * @notice Computes the trie root from a given path.\n     * @param _nodes Path to some k/v pair.\n     * @param _key Key for the k/v pair.\n     * @return _updatedRoot Root hash for the updated trie.\n     */\n    function _getUpdatedTrieRoot(\n        TrieNode[] memory _nodes,\n        bytes memory _key\n    )\n        private\n        pure\n        returns (\n            bytes32 _updatedRoot\n        )\n    {\n        bytes memory key = Lib_BytesUtils.toNibbles(_key);\n\n        // Some variables to keep track of during iteration.\n        TrieNode memory currentNode;\n        NodeType currentNodeType;\n        bytes memory previousNodeHash;\n\n        // Run through the path backwards to rebuild our root hash.\n        for (uint256 i = _nodes.length; i > 0; i--) {\n            // Pick out the current node.\n            currentNode = _nodes[i - 1];\n            currentNodeType = _getNodeType(currentNode);\n\n            if (currentNodeType == NodeType.LeafNode) {\n                // Leaf nodes are already correctly encoded.\n                // Shift the key over to account for the nodes key.\n                bytes memory nodeKey = _getNodeKey(currentNode);\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\n            } else if (currentNodeType == NodeType.ExtensionNode) {\n                // Shift the key over to account for the nodes key.\n                bytes memory nodeKey = _getNodeKey(currentNode);\n                key = Lib_BytesUtils.slice(key, 0, key.length - nodeKey.length);\n\n                // If this node is the last element in the path, it'll be correctly encoded\n                // and we can skip this part.\n                if (previousNodeHash.length > 0) {\n                    // Re-encode the node based on the previous node.\n                    currentNode = _makeExtensionNode(nodeKey, previousNodeHash);\n                }\n            } else if (currentNodeType == NodeType.BranchNode) {\n                // If this node is the last element in the path, it'll be correctly encoded\n                // and we can skip this part.\n                if (previousNodeHash.length > 0) {\n                    // Re-encode the node based on the previous node.\n                    uint8 branchKey = uint8(key[key.length - 1]);\n                    key = Lib_BytesUtils.slice(key, 0, key.length - 1);\n                    currentNode = _editBranchIndex(currentNode, branchKey, previousNodeHash);\n                }\n            }\n\n            // Compute the node hash for the next iteration.\n            previousNodeHash = _getNodeHash(currentNode.encoded);\n        }\n\n        // Current node should be the root at this point.\n        // Simply return the hash of its encoding.\n        return keccak256(currentNode.encoded);\n    }\n\n    /**\n     * @notice Parses an RLP-encoded proof into something more useful.\n     * @param _proof RLP-encoded proof to parse.\n     * @return _parsed Proof parsed into easily accessible structs.\n     */\n    function _parseProof(\n        bytes memory _proof\n    )\n        private\n        pure\n        returns (\n            TrieNode[] memory _parsed\n        )\n    {\n        Lib_RLPReader.RLPItem[] memory nodes = Lib_RLPReader.readList(_proof);\n        TrieNode[] memory proof = new TrieNode[](nodes.length);\n\n        for (uint256 i = 0; i < nodes.length; i++) {\n            bytes memory encoded = Lib_RLPReader.readBytes(nodes[i]);\n            proof[i] = TrieNode({\n                encoded: encoded,\n                decoded: Lib_RLPReader.readList(encoded)\n            });\n        }\n\n        return proof;\n    }\n\n    /**\n     * @notice Picks out the ID for a node. Node ID is referred to as the\n     * \"hash\" within the specification, but nodes < 32 bytes are not actually\n     * hashed.\n     * @param _node Node to pull an ID for.\n     * @return _nodeID ID for the node, depending on the size of its contents.\n     */\n    function _getNodeID(\n        Lib_RLPReader.RLPItem memory _node\n    )\n        private\n        pure\n        returns (\n            bytes32 _nodeID\n        )\n    {\n        bytes memory nodeID;\n\n        if (_node.length < 32) {\n            // Nodes smaller than 32 bytes are RLP encoded.\n            nodeID = Lib_RLPReader.readRawBytes(_node);\n        } else {\n            // Nodes 32 bytes or larger are hashed.\n            nodeID = Lib_RLPReader.readBytes(_node);\n        }\n\n        return Lib_BytesUtils.toBytes32(nodeID);\n    }\n\n    /**\n     * @notice Gets the path for a leaf or extension node.\n     * @param _node Node to get a path for.\n     * @return _path Node path, converted to an array of nibbles.\n     */\n    function _getNodePath(\n        TrieNode memory _node\n    )\n        private\n        pure\n        returns (\n            bytes memory _path\n        )\n    {\n        return Lib_BytesUtils.toNibbles(Lib_RLPReader.readBytes(_node.decoded[0]));\n    }\n\n    /**\n     * @notice Gets the key for a leaf or extension node. Keys are essentially\n     * just paths without any prefix.\n     * @param _node Node to get a key for.\n     * @return _key Node key, converted to an array of nibbles.\n     */\n    function _getNodeKey(\n        TrieNode memory _node\n    )\n        private\n        pure\n        returns (\n            bytes memory _key\n        )\n    {\n        return _removeHexPrefix(_getNodePath(_node));\n    }\n\n    /**\n     * @notice Gets the path for a node.\n     * @param _node Node to get a value for.\n     * @return _value Node value, as hex bytes.\n     */\n    function _getNodeValue(\n        TrieNode memory _node\n    )\n        private\n        pure\n        returns (\n            bytes memory _value\n        )\n    {\n        return Lib_RLPReader.readBytes(_node.decoded[_node.decoded.length - 1]);\n    }\n\n    /**\n     * @notice Computes the node hash for an encoded node. Nodes < 32 bytes\n     * are not hashed, all others are keccak256 hashed.\n     * @param _encoded Encoded node to hash.\n     * @return _hash Hash of the encoded node. Simply the input if < 32 bytes.\n     */\n    function _getNodeHash(\n        bytes memory _encoded\n    )\n        private\n        pure\n        returns (\n            bytes memory _hash\n        )\n    {\n        if (_encoded.length < 32) {\n            return _encoded;\n        } else {\n            return abi.encodePacked(keccak256(_encoded));\n        }\n    }\n\n    /**\n     * @notice Determines the type for a given node.\n     * @param _node Node to determine a type for.\n     * @return _type Type of the node; BranchNode/ExtensionNode/LeafNode.\n     */\n    function _getNodeType(\n        TrieNode memory _node\n    )\n        private\n        pure\n        returns (\n            NodeType _type\n        )\n    {\n        if (_node.decoded.length == BRANCH_NODE_LENGTH) {\n            return NodeType.BranchNode;\n        } else if (_node.decoded.length == LEAF_OR_EXTENSION_NODE_LENGTH) {\n            bytes memory path = _getNodePath(_node);\n            uint8 prefix = uint8(path[0]);\n\n            if (prefix == PREFIX_LEAF_EVEN || prefix == PREFIX_LEAF_ODD) {\n                return NodeType.LeafNode;\n            } else if (prefix == PREFIX_EXTENSION_EVEN || prefix == PREFIX_EXTENSION_ODD) {\n                return NodeType.ExtensionNode;\n            }\n        }\n\n        revert(\"Invalid node type\");\n    }\n\n    /**\n     * @notice Utility; determines the number of nibbles shared between two\n     * nibble arrays.\n     * @param _a First nibble array.\n     * @param _b Second nibble array.\n     * @return _shared Number of shared nibbles.\n     */\n    function _getSharedNibbleLength(\n        bytes memory _a,\n        bytes memory _b\n    )\n        private\n        pure\n        returns (\n            uint256 _shared\n        )\n    {\n        uint256 i = 0;\n        while (_a.length > i && _b.length > i && _a[i] == _b[i]) {\n            i++;\n        }\n        return i;\n    }\n\n    /**\n     * @notice Utility; converts an RLP-encoded node into our nice struct.\n     * @param _raw RLP-encoded node to convert.\n     * @return _node Node as a TrieNode struct.\n     */\n    function _makeNode(\n        bytes[] memory _raw\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _node\n        )\n    {\n        bytes memory encoded = Lib_RLPWriter.writeList(_raw);\n\n        return TrieNode({\n            encoded: encoded,\n            decoded: Lib_RLPReader.readList(encoded)\n        });\n    }\n\n    /**\n     * @notice Utility; converts an RLP-decoded node into our nice struct.\n     * @param _items RLP-decoded node to convert.\n     * @return _node Node as a TrieNode struct.\n     */\n    function _makeNode(\n        Lib_RLPReader.RLPItem[] memory _items\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _node\n        )\n    {\n        bytes[] memory raw = new bytes[](_items.length);\n        for (uint256 i = 0; i < _items.length; i++) {\n            raw[i] = Lib_RLPReader.readRawBytes(_items[i]);\n        }\n        return _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates a new extension node.\n     * @param _key Key for the extension node, unprefixed.\n     * @param _value Value for the extension node.\n     * @return _node New extension node with the given k/v pair.\n     */\n    function _makeExtensionNode(\n        bytes memory _key,\n        bytes memory _value\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _node\n        )\n    {\n        bytes[] memory raw = new bytes[](2);\n        bytes memory key = _addHexPrefix(_key, false);\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\n        return _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates a new leaf node.\n     * @dev This function is essentially identical to `_makeExtensionNode`.\n     * Although we could route both to a single method with a flag, it's\n     * more gas efficient to keep them separate and duplicate the logic.\n     * @param _key Key for the leaf node, unprefixed.\n     * @param _value Value for the leaf node.\n     * @return _node New leaf node with the given k/v pair.\n     */\n    function _makeLeafNode(\n        bytes memory _key,\n        bytes memory _value\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _node\n        )\n    {\n        bytes[] memory raw = new bytes[](2);\n        bytes memory key = _addHexPrefix(_key, true);\n        raw[0] = Lib_RLPWriter.writeBytes(Lib_BytesUtils.fromNibbles(key));\n        raw[1] = Lib_RLPWriter.writeBytes(_value);\n        return _makeNode(raw);\n    }\n\n    /**\n     * @notice Creates an empty branch node.\n     * @return _node Empty branch node as a TrieNode struct.\n     */\n    function _makeEmptyBranchNode()\n        private\n        pure\n        returns (\n            TrieNode memory _node\n        )\n    {\n        bytes[] memory raw = new bytes[](BRANCH_NODE_LENGTH);\n        for (uint256 i = 0; i < raw.length; i++) {\n            raw[i] = RLP_NULL_BYTES;\n        }\n        return _makeNode(raw);\n    }\n\n    /**\n     * @notice Modifies the value slot for a given branch.\n     * @param _branch Branch node to modify.\n     * @param _value Value to insert into the branch.\n     * @return _updatedNode Modified branch node.\n     */\n    function _editBranchValue(\n        TrieNode memory _branch,\n        bytes memory _value\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _updatedNode\n        )\n    {\n        bytes memory encoded = Lib_RLPWriter.writeBytes(_value);\n        _branch.decoded[_branch.decoded.length - 1] = Lib_RLPReader.toRLPItem(encoded);\n        return _makeNode(_branch.decoded);\n    }\n\n    /**\n     * @notice Modifies a slot at an index for a given branch.\n     * @param _branch Branch node to modify.\n     * @param _index Slot index to modify.\n     * @param _value Value to insert into the slot.\n     * @return _updatedNode Modified branch node.\n     */\n    function _editBranchIndex(\n        TrieNode memory _branch,\n        uint8 _index,\n        bytes memory _value\n    )\n        private\n        pure\n        returns (\n            TrieNode memory _updatedNode\n        )\n    {\n        bytes memory encoded = _value.length < 32 ? _value : Lib_RLPWriter.writeBytes(_value);\n        _branch.decoded[_index] = Lib_RLPReader.toRLPItem(encoded);\n        return _makeNode(_branch.decoded);\n    }\n\n    /**\n     * @notice Utility; adds a prefix to a key.\n     * @param _key Key to prefix.\n     * @param _isLeaf Whether or not the key belongs to a leaf.\n     * @return _prefixedKey Prefixed key.\n     */\n    function _addHexPrefix(\n        bytes memory _key,\n        bool _isLeaf\n    )\n        private\n        pure\n        returns (\n            bytes memory _prefixedKey\n        )\n    {\n        uint8 prefix = _isLeaf ? uint8(0x02) : uint8(0x00);\n        uint8 offset = uint8(_key.length % 2);\n        bytes memory prefixed = new bytes(2 - offset);\n        prefixed[0] = bytes1(prefix + offset);\n        return abi.encodePacked(prefixed, _key);\n    }\n\n    /**\n     * @notice Utility; removes a prefix from a path.\n     * @param _path Path to remove the prefix from.\n     * @return _unprefixedKey Unprefixed key.\n     */\n    function _removeHexPrefix(\n        bytes memory _path\n    )\n        private\n        pure\n        returns (\n            bytes memory _unprefixedKey\n        )\n    {\n        if (uint8(_path[0]) % 2 == 0) {\n            return Lib_BytesUtils.slice(_path, 2);\n        } else {\n            return Lib_BytesUtils.slice(_path, 1);\n        }\n    }\n\n    /**\n     * @notice Utility; combines two node arrays. Array lengths are required\n     * because the actual lengths may be longer than the filled lengths.\n     * Array resizing is extremely costly and should be avoided.\n     * @param _a First array to join.\n     * @param _aLength Length of the first array.\n     * @param _b Second array to join.\n     * @param _bLength Length of the second array.\n     * @return _joined Combined node array.\n     */\n    function _joinNodeArrays(\n        TrieNode[] memory _a,\n        uint256 _aLength,\n        TrieNode[] memory _b,\n        uint256 _bLength\n    )\n        private\n        pure\n        returns (\n            TrieNode[] memory _joined\n        )\n    {\n        TrieNode[] memory ret = new TrieNode[](_aLength + _bLength);\n\n        // Copy elements from the first array.\n        for (uint256 i = 0; i < _aLength; i++) {\n            ret[i] = _a[i];\n        }\n\n        // Copy elements from the second array.\n        for (uint256 i = 0; i < _bLength; i++) {\n            ret[i + _aLength] = _b[i];\n        }\n\n        return ret;\n    }\n}\n"
    },
    "contracts/libraries/Lib_BytesUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\n\n/**\n * @title Lib_BytesUtils\n */\nlibrary Lib_BytesUtils {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_start + _length >= _start, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        if (_bytes.length - _start == 0) {\n            return bytes('');\n        }\n\n        return slice(_bytes, _start, _bytes.length - _start);\n    }\n\n    function toBytes32PadLeft(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        bytes32 ret;\n        uint256 len = _bytes.length <= 32 ? _bytes.length : 32;\n        assembly {\n            ret := shr(mul(sub(32, len), 8), mload(add(_bytes, 32)))\n        }\n        return ret;\n    }\n\n    function toBytes32(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        if (_bytes.length < 32) {\n            bytes32 ret;\n            assembly {\n                ret := mload(add(_bytes, 32))\n            }\n            return ret;\n        }\n\n        return abi.decode(_bytes,(bytes32)); // will truncate if input length > 32 bytes\n    }\n\n    function toUint256(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (uint256)\n    {\n        return uint256(toBytes32(_bytes));\n    }\n\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\n        require(_start + 3 >= _start, \"toUint24_overflow\");\n        require(_bytes.length >= _start + 3 , \"toUint24_outOfBounds\");\n        uint24 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x3), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_start + 1 >= _start, \"toUint8_overflow\");\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_start + 20 >= _start, \"toAddress_overflow\");\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory nibbles = new bytes(_bytes.length * 2);\n\n        for (uint256 i = 0; i < _bytes.length; i++) {\n            nibbles[i * 2] = _bytes[i] >> 4;\n            nibbles[i * 2 + 1] = bytes1(uint8(_bytes[i]) % 16);\n        }\n\n        return nibbles;\n    }\n\n    function fromNibbles(\n        bytes memory _bytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory ret = new bytes(_bytes.length / 2);\n\n        for (uint256 i = 0; i < ret.length; i++) {\n            ret[i] = (_bytes[i * 2] << 4) | (_bytes[i * 2 + 1]);\n        }\n\n        return ret;\n    }\n\n    function equal(\n        bytes memory _bytes,\n        bytes memory _other\n    )\n        internal\n        pure\n        returns (bool)\n    {\n        return keccak256(_bytes) == keccak256(_other);\n    }\n}\n"
    },
    "contracts/libraries/Lib_RLPWriter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >0.5.0 <0.8.0;\npragma experimental ABIEncoderV2;\n\n/* Library Imports */\nimport { Lib_BytesUtils } from \"./Lib_BytesUtils.sol\";\n\n/**\n * @title Lib_RLPWriter\n * @author Bakaoh (with modifications)\n */\nlibrary Lib_RLPWriter {\n\n    /**********************\n     * Internal Functions *\n     **********************/\n\n    /**\n     * RLP encodes a byte string.\n     * @param _in The byte string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeBytes(\n        bytes memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded;\n\n        if (_in.length == 1 && uint8(_in[0]) < 128) {\n            encoded = _in;\n        } else {\n            encoded = abi.encodePacked(_writeLength(_in.length, 128), _in);\n        }\n\n        return encoded;\n    }\n\n    /**\n     * RLP encodes a list of RLP encoded byte byte strings.\n     * @param _in The list of RLP encoded byte strings.\n     * @return _out The RLP encoded list of items in bytes.\n     */\n    function writeList(\n        bytes[] memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory list = _flatten(_in);\n        return abi.encodePacked(_writeLength(list.length, 192), list);\n    }\n\n    /**\n     * RLP encodes a string.\n     * @param _in The string to encode.\n     * @return _out The RLP encoded string in bytes.\n     */\n    function writeString(\n        string memory _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(bytes(_in));\n    }\n\n    /**\n     * RLP encodes an address.\n     * @param _in The address to encode.\n     * @return _out The RLP encoded address in bytes.\n     */\n    function writeAddress(\n        address _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a bytes32 value.\n     * @param _in The bytes32 to encode.\n     * @return _out The RLP encoded bytes32 in bytes.\n     */\n    function writeBytes32(\n        bytes32 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(abi.encodePacked(_in));\n    }\n\n    /**\n     * RLP encodes a uint.\n     * @param _in The uint256 to encode.\n     * @return _out The RLP encoded uint256 in bytes.\n     */\n    function writeUint(\n        uint256 _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        return writeBytes(_toBinary(_in));\n    }\n\n    /**\n     * RLP encodes a bool.\n     * @param _in The bool to encode.\n     * @return _out The RLP encoded bool in bytes.\n     */\n    function writeBool(\n        bool _in\n    )\n        internal\n        pure\n        returns (\n            bytes memory _out\n        )\n    {\n        bytes memory encoded = new bytes(1);\n        encoded[0] = (_in ? bytes1(0x01) : bytes1(0x80));\n        return encoded;\n    }\n\n\n    /*********************\n     * Private Functions *\n     *********************/\n\n    /**\n     * Encode the first byte, followed by the `len` in binary form if `length` is more than 55.\n     * @param _len The length of the string or the payload.\n     * @param _offset 128 if item is string, 192 if item is list.\n     * @return _encoded RLP encoded bytes.\n     */\n    function _writeLength(\n        uint256 _len,\n        uint256 _offset\n    )\n        private\n        pure\n        returns (\n            bytes memory _encoded\n        )\n    {\n        bytes memory encoded;\n\n        if (_len < 56) {\n            encoded = new bytes(1);\n            encoded[0] = byte(uint8(_len) + uint8(_offset));\n        } else {\n            uint256 lenLen;\n            uint256 i = 1;\n            while (_len / i != 0) {\n                lenLen++;\n                i *= 256;\n            }\n\n            encoded = new bytes(lenLen + 1);\n            encoded[0] = byte(uint8(lenLen) + uint8(_offset) + 55);\n            for(i = 1; i <= lenLen; i++) {\n                encoded[i] = byte(uint8((_len / (256**(lenLen-i))) % 256));\n            }\n        }\n\n        return encoded;\n    }\n\n    /**\n     * Encode integer in big endian binary form with no leading zeroes.\n     * @notice TODO: This should be optimized with assembly to save gas costs.\n     * @param _x The integer to encode.\n     * @return _binary RLP encoded bytes.\n     */\n    function _toBinary(\n        uint256 _x\n    )\n        private\n        pure\n        returns (\n            bytes memory _binary\n        )\n    {\n        bytes memory b = abi.encodePacked(_x);\n\n        uint256 i = 0;\n        for (; i < 32; i++) {\n            if (b[i] != 0) {\n                break;\n            }\n        }\n\n        bytes memory res = new bytes(32 - i);\n        for (uint256 j = 0; j < res.length; j++) {\n            res[j] = b[i++];\n        }\n\n        return res;\n    }\n\n    /**\n     * Copies a piece of memory to another location.\n     * @notice From: https://github.com/Arachnid/solidity-stringutils/blob/master/src/strings.sol.\n     * @param _dest Destination location.\n     * @param _src Source location.\n     * @param _len Length of memory to copy.\n     */\n    function _memcpy(\n        uint256 _dest,\n        uint256 _src,\n        uint256 _len\n    )\n        private\n        pure\n    {\n        uint256 dest = _dest;\n        uint256 src = _src;\n        uint256 len = _len;\n\n        for(; len >= 32; len -= 32) {\n            assembly {\n                mstore(dest, mload(src))\n            }\n            dest += 32;\n            src += 32;\n        }\n\n        uint256 mask = 256 ** (32 - len) - 1;\n        assembly {\n            let srcpart := and(mload(src), not(mask))\n            let destpart := and(mload(dest), mask)\n            mstore(dest, or(destpart, srcpart))\n        }\n    }\n\n    /**\n     * Flattens a list of byte strings into one byte string.\n     * @notice From: https://github.com/sammayo/solidity-rlp-encoder/blob/master/RLPEncode.sol.\n     * @param _list List of byte strings to flatten.\n     * @return _flattened The flattened byte string.\n     */\n    function _flatten(\n        bytes[] memory _list\n    )\n        private\n        pure\n        returns (\n            bytes memory _flattened\n        )\n    {\n        if (_list.length == 0) {\n            return new bytes(0);\n        }\n\n        uint256 len;\n        uint256 i = 0;\n        for (; i < _list.length; i++) {\n            len += _list[i].length;\n        }\n\n        bytes memory flattened = new bytes(len);\n        uint256 flattenedPtr;\n        assembly { flattenedPtr := add(flattened, 0x20) }\n\n        for(i = 0; i < _list.length; i++) {\n            bytes memory item = _list[i];\n\n            uint256 listPtr;\n            assembly { listPtr := add(item, 0x20)}\n\n            _memcpy(flattenedPtr, listPtr, item.length);\n            flattenedPtr += _list[i].length;\n        }\n\n        return flattened;\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}